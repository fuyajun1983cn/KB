<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Android学习笔记</title>
<!-- 2019-04-11 Thu 13:58 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Fu Yajun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css" />
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css" />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js" type="text/javascript"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js" type="text/javascript"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Android学习笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 通用概念</a>
<ul>
<li><a href="#sec-1-1">1.1. Android框架图</a></li>
<li><a href="#sec-1-2">1.2. Android应用程序框架</a></li>
<li><a href="#sec-1-3">1.3. UI基本开发</a></li>
<li><a href="#sec-1-4">1.4. Fragment</a></li>
<li><a href="#sec-1-5">1.5. 进程与线程</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. 线程调度（Thread Scheduling）</a></li>
<li><a href="#sec-1-5-2">1.5.2. 启动线程</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. 安全策略</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Framework</a>
<ul>
<li><a href="#sec-2-1">2.1. Audio System</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. Audio System 介绍</a></li>
<li><a href="#sec-2-1-2">2.1.2. AudioTrack 介绍</a></li>
<li><a href="#sec-2-1-3">2.1.3. AudioRecord介绍</a></li>
<li><a href="#sec-2-1-4">2.1.4. AudioPolicyService介绍</a></li>
<li><a href="#sec-2-1-5">2.1.5. AudioFlinger</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. Media Framework</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. 基础知识</a></li>
<li><a href="#sec-2-2-2">2.2.2. 主要代码路径</a></li>
<li><a href="#sec-2-2-3">2.2.3. Stagefright</a></li>
<li><a href="#sec-2-2-4">2.2.4. NuPlayer</a></li>
<li><a href="#sec-2-2-5">2.2.5. OpenMAX</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3. Graphics</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. Android Graphics Pipeline Overview</a></li>
<li><a href="#sec-2-3-2">2.3.2. Android Sync Framework</a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4. Input System</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. Architecture (ICS)</a></li>
<li><a href="#sec-2-4-2">2.4.2. Architecture (JB)</a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5. Wifi Framework</a>
<ul>
<li><a href="#sec-2-5-1">2.5.1. Common</a></li>
<li><a href="#sec-2-5-2">2.5.2. 传统WiFi</a></li>
<li><a href="#sec-2-5-3">2.5.3. P2P/Miracast</a></li>
<li><a href="#sec-2-5-4">2.5.4. SoftAp</a></li>
<li><a href="#sec-2-5-5">2.5.5. 主要流程总结</a></li>
</ul>
</li>
<li><a href="#sec-2-6">2.6. Global Settings</a>
<ul>
<li><a href="#sec-2-6-1">2.6.1. Settings.java</a></li>
<li><a href="#sec-2-6-2">2.6.2. defaults.xml</a></li>
<li><a href="#sec-2-6-3">2.6.3. DatabaseHelper.java</a></li>
<li><a href="#sec-2-6-4">2.6.4. 访问</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Android 8.0 architecture</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 通用概念</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Android框架图</h3>
<div class="outline-text-3" id="text-1-1">

<div class="figure">
<p><img src="../images/2016/2016071201.png" alt="2016071201.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Android应用程序框架</h3>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> UI基本开发</h3>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Fragment</h3>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 进程与线程</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Android世界的Process按优先级分为如下几类：
</p>
<ol class="org-ol">
<li>Top
<ul class="org-ul">
<li>Active
</li>
</ul>
</li>
<li>High
<ul class="org-ul">
<li>Visbile
</li>
<li>Service
</li>
</ul>
</li>
<li>Low
<ul class="org-ul">
<li>Background
</li>
<li>Empty
</li>
</ul>
<p>
进程的优先级从高到低依次分为五类，越往下，在内存紧张的时候越有可
  能被系统杀掉。简而言之，越是容易被用户感知到的进程，其优先级必
  定更高。
</p>
</li>
</ol>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> 线程调度（Thread Scheduling）</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Linux系统的调度器在分配time slice的时候，采用的
CFS（completely fair scheduler）策略。这种策略不但会参考单个
线程的优先级，还会追踪每个线程已经获取到的time slice数量，如
果高优先级的线程已经执行了很长时间，但低优先级的线程一直在等
待，后续系统会保证低优先级的线程也能获取更多的CPU时间。显然使
用这种调度策略的话，优先级高的线程并不一定能在争取time slice
上有绝对的优势，所以Android系统在线程调度上使用了cgroups的概
念，cgroups能更好的凸显某些线程的重要性，使得优先级更高的线程
明确的获取到更多的time slice。
</p>

<p>
Android将线程分为多个group，其中两类group尤其重要。一类是
default group，UI线程属于这一类。另一类是background group，工
作线程应该归属到这一类。background group当中所有的线程加起来
总共也只能分配到5～10%的time slice，剩下的全部分配给default
group，这样设计显然能保证UI线程绘制UI的流畅性。
</p>

<p>
Android开发者需要显式的将工作线程归于background group以降低工
作线程的优先级：
</p>
<div class="org-src-container">

<pre class="src src-java">new 
Thread(
       new 
       Runnable() {
           @Override
           public 
               void 
               run() {
               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
           }
       }).start();
</pre>
</div>

<p>
所以在我们决定新启一个线程执行任务的时候，首先要问自己这个任
务在完成时间上是否重要到要和UI线程争夺CPU资源。如果不是，降低
线程优先级将其归于background group，如果是，则需要进一步的
profile看这个线程是否造成UI线程的卡顿。
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> 启动线程</h4>
<div class="outline-text-4" id="text-1-5-2">
</div><ol class="org-ol"><li><a id="sec-1-5-2-1" name="sec-1-5-2-1"></a>new Thread()<br  /><div class="outline-text-5" id="text-1-5-2-1">
<p>
这是Android系统里开线程最简单的方式，也只能应用于最简单的场
景，简单的好处却伴随不少的隐患。 
</p>
<div class="org-src-container">

<pre class="src src-java">public void runCode(View v) {
    log("Running code");
    displayProgressBar(true);
    Runnable runnable = new Runnable() {
            @Override
            public void run() {

                  Log.i(TAG, "run: starting thread for 4 seconds");
                  try {
                  Thread.sleep(4000);
                  } catch (InterruptedException e) {
                  e.printStackTrace();
                  }

                Message message = new Message();
                Bundle bundle = new Bundle();
                bundle.putString(MESSAGE_KEY, "thread is complete");
                message.setData(bundle);
                mHandler.sendMessage(message);

            }
        };

    Thread thread = new Thread(runnable);
    thread.start();
}
</pre>
</div>

<p>
这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状
态的管理。start之后，run当中的代码就一定会执行到底，无法中
途取消。 
</p>

<p>
Runnable作为匿名内部类还持有了外部类的引用，在线程退出之前，
该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成
内存泄漏。 
</p>

<p>
没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外
的线程切换代码。
</p>

<p>
如果从UI线程启动，则该线程优先级默认为Default，归于default
cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在
对UI性能要求高的场景下要记得
</p>
<pre class="example">
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
</pre>

<p>
虽说处于background group的线程总共只能争取到5～10%的CPU资源，
但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来
说，都是快到无法感知，所以我们一般都偏向于在background
group当中执行工作线程任务。
</p>
</div>
</li>




<li><a id="sec-1-5-2-2" name="sec-1-5-2-2"></a>AsyncTask<br  /><div class="outline-text-5" id="text-1-5-2-2">
<p>
例子如下：
</p>
<div class="org-src-container">

<pre class="src src-java">package com.example.android.concurrency;

import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.ScrollView;
import android.widget.TextView;

public class MainActivity_Async extends AppCompatActivity {

    private static final String TAG = "CodeRunner";

    // View object references
    private ScrollView mScroll;
    private TextView mLog;
    private ProgressBar mProgressBar;
    private MyTask mTask;
    private boolean mTaskRunning;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Initialize the logging components
        mScroll = (ScrollView) findViewById(R.id.scrollLog);
        mLog = (TextView) findViewById(R.id.tvLog);
        mProgressBar = (ProgressBar) findViewById(R.id.progress_bar);

        mLog.setText(R.string.lorem_ipsum);

    }

    //  Run some code, called from the onClick event in the layout file
    public void runCode(View v) {

        if (mTaskRunning &amp;&amp; mTask != null) {
            mTask.cancel(true);
            mTaskRunning = false;
        } else {
            mTask = new MyTask();
            mTask.execute("Red", "Green", "Blue");
            mTaskRunning = true;
        }

    }

    //  Clear the output, called from the onClick event in the layout file
    public void clearOutput(View v) {
        mLog.setText("");
        scrollTextToEnd();
    }

    //  Log output to logcat and the screen
    @SuppressWarnings("unused")
    private void log(String message) {
        Log.i(TAG, message);
        mLog.append(message + "\n");
        scrollTextToEnd();
    }

    private void scrollTextToEnd() {
        mScroll.post(new Runnable() {
            @Override
            public void run() {
                mScroll.fullScroll(ScrollView.FOCUS_DOWN);
            }
        });
    }

    @SuppressWarnings("unused")
    private void displayProgressBar(boolean display) {
        if (display) {
            mProgressBar.setVisibility(View.VISIBLE);
        } else {
            mProgressBar.setVisibility(View.INVISIBLE);
        }
    }

    class MyTask extends AsyncTask&lt;String, String, String&gt; {
        @Override
        protected String doInBackground(String... strings) {
            for (String value :
                    strings) {
                if (isCancelled()) {
                    publishProgress("Cancelled");
                    break;
                }
                Log.i(TAG, "doInBackground: " + value);
                publishProgress(value);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return "thread all done!";
        }

        @Override
        protected void onProgressUpdate(String... values) {
            log(values[0]);
        }

        @Override
        protected void onPostExecute(String s) {
            log(s);
        }

        @Override
        protected void onCancelled() {
            log("Task cancelled");
        }

        @Override
        protected void onCancelled(String s) {
            log("Cancelled with result " + s);
        }
    }

}
</pre>
</div>


<p>
和使用Thread()不同的是，多了几处API回调来严格规范工作线程与
UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比
如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到
ImageView控件需要切换到UI线程。
</p>

<p>
AsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管
理上较之Thread()方式更为灵活。值得注意的是AsyncTask的
cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel
的状态值来决定是否中止任务。
</p>

<p>
AsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防
止出现意外的内存泄漏。
</p>

<p>
AsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，
被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要
明确任务是串行还是并行。
</p>

<p>
线程优先级为background，对UI线程的执行影响极小。
</p>
</div>
</li>

<li><a id="sec-1-5-2-3" name="sec-1-5-2-3"></a>HandlerThhread<br  /><div class="outline-text-5" id="text-1-5-2-3">
<p>
在需要对多任务做更精细控制，线程切换更频繁的场景之下，
Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任
这些需求甚至更多。 
</p>

<p>
HandlerThread将Handler，Thread，Looper，MessageQueue几个概
念相结合。Handler是线程对外的接口，所有新的message或者
runnable都通过handler post到工作线程。Looper在MessageQueue
取到新的任务就切换到工作线程去执行。不同的post方法可以让我
们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。
HandlerThread最大的优势在于引入MessageQueue概念，可以进行多
任务队列管理。 
</p>

<p>
HandlerThread背后只有一个线程，所以任务是串行执行的。串行相
对于并行来说更安全，各任务之间不会存在多线程安全问题。
</p>

<p>
HandlerThread所产生的线程会一直存活，Looper会在该线程中持续
的检查MessageQueue。这一点和Thread()，AsyncTask都不同，
thread实例的重用可以避免线程相关的对象的频繁重建和销毁。
</p>

<p>
HandlerThread较之Thread()，AsyncTask需要写更多的代码，但在
实用性，灵活度，安全性上都有更好的表现。
</p>
</div>
</li>



<li><a id="sec-1-5-2-4" name="sec-1-5-2-4"></a>ThreadPoolExecutor<br  /><div class="outline-text-5" id="text-1-5-2-4">
<p>
Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合
串行处理多任务的场景。当需要并行的处理多任务之时，
ThreadPoolExecutor是更好的选择
</p>

<div class="org-src-container">

<pre class="src src-java">//  Run some code, called from the onClick event in the layout file
public void runCode(View v) {
    for (int i = 0; i &lt; 10; i++) {
        Runnable worker = new BackgroundTask(i);
        mExecutor.execute(worker);
    }
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-java">public class BackgroundTask implements Runnable {
    public static final String TAG = "CodeRunner";
    private int threadNumber;

    public BackgroundTask(int threadNumber) {
        this.threadNumber = threadNumber;
    }

    @Override
    public void run() {

        Log.i(TAG, Thread.currentThread().getName() +
              " start, thread number = " + threadNumber);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Log.i(TAG, Thread.currentThread().getName() +
              " end, thread number = " + threadNumber);

    }

}
</pre>
</div>
</div>
</li>

<li><a id="sec-1-5-2-5" name="sec-1-5-2-5"></a>IntentService<br  /><div class="outline-text-5" id="text-1-5-2-5">
<p>
IntentService又是另一种开工作线程的方式，从名字就可以看出这
个工作线程会带有service的属性。和AsyncTask不同，没有和UI线
程的交互，也不像HandlerThread的工作线程会一直存活。
IntentService背后其实也有一个HandlerThread来串行的处理
Message Queue，从IntentService的onCreate方法可以看出： 
</p>

<div class="org-src-container">

<pre class="src src-java">@Override
public void onCreate() {
    // TODO: It would be nice to have an option to hold a partial wakelock
    // during processing, and to have a static startService(Context, Intent)
    // method that would launch the service &amp; hand off a wakelock.
    super.onCreate();
    HandlerThread thread = 
        new HandlerThread(
                      "IntentService[" 
                      + mName + 
                      "]"
                      );
    thread.start();
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
}
</pre>
</div>

<p>
只不过在所有的Message处理完毕之后，工作线程会自动结束。所以
可以把IntentService看做是Service和HandlerThread的结合体，适
合需要在工作线程处理UI无关任务的场景。 
</p>

<p>
IntentService的一个使用实例：
</p>

<div class="org-src-container">

<pre class="src src-java">package com.example.android.concurrency.services;

import android.app.IntentService;
import android.content.Intent;
import android.content.Context;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;

public class MyIntentService extends IntentService {
    private static final String ACTION_FOO = "com.example.android.concurrency.action.FOO";

    private static final String EXTRA_PARAM1 = "com.example.android.concurrency.extra.PARAM1";
    private static final String EXTRA_PARAM2 = "com.example.android.concurrency.extra.PARAM2";
    public static final String TAG = "CodeRunner";
    public static final String SERVICE_MESSAGE = "ServiceMessage";
    public static final String MESSAGE_KEY = "message";

    public MyIntentService() {
        super("MyIntentService");
    }

    public static void startActionFoo(Context context, String param1, String param2) {
        Intent intent = new Intent(context, MyIntentService.class);
        intent.setAction(ACTION_FOO);
        intent.putExtra(EXTRA_PARAM1, param1);
        intent.putExtra(EXTRA_PARAM2, param2);
        context.startService(intent);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        if (intent != null) {
            final String action = intent.getAction();
            if (ACTION_FOO.equals(action)) {
                final String param1 = intent.getStringExtra(EXTRA_PARAM1);
                final String param2 = intent.getStringExtra(EXTRA_PARAM2);
                handleActionFoo(param1, param2);
            }
        }
    }

    private void handleActionFoo(String param1, String param2) {
        sendMessage("handleActionFoo: service started");
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        sendMessage("handleActionFoo: service finished");
    }

    @Override
    public void onCreate() {
        super.onCreate();
        sendMessage("onCreate");
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        sendMessage("onDestroy");
    }

    private void sendMessage(String message) {
        Intent intent = new Intent(SERVICE_MESSAGE);
        intent.putExtra(MESSAGE_KEY, message);
        LocalBroadcastManager.getInstance(getApplicationContext())
                .sendBroadcast(intent);
    }
}
</pre>
</div>

<p>
在Activity可以通过如下方式调用上述IntentService，与UI Activity的通信
可以通过LocalBroadcastManager来进行.
</p>

<div class="org-src-container">

<pre class="src src-java">BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String message = intent.getStringExtra(MyIntentService.MESSAGE_KEY);
            log(message);
        }
    };


//  Run some code, called from the onClick event in the layout file
public void runCode(View v) {
    log("Running code");
    MyIntentService.startActionFoo(this, "Value 1", "Value 2");
}
</pre>
</div>
</div>
</li>

<li><a id="sec-1-5-2-6" name="sec-1-5-2-6"></a>JobService<br  /><div class="outline-text-5" id="text-1-5-2-6">
<div class="org-src-container">

<pre class="src src-java">package com.example.android.concurrency;

import android.app.job.JobParameters;
import android.app.job.JobService;
import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;

public class MyJobService extends JobService {

    public static final String TAG = "CodeRunner";

    public MyJobService() {
    }

    @Override
    public boolean onStartJob(final JobParameters jobParameters) {
        Log.i(TAG, "onStartJob: " + jobParameters.getJobId());
//        jobFinished(jobParameters, false);

        Runnable r = new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Log.i(TAG, "run: job complete");

                LocalBroadcastManager.getInstance(getApplicationContext())
                        .sendBroadcast(new Intent("ServiceMessage"));

                jobFinished(jobParameters, false);
            }
        };
        Thread thread = new Thread(r);
        thread.start();

        return true;
    }

    @Override
    public boolean onStopJob(JobParameters jobParameters) {
        Log.i(TAG, "onStopJob: " + jobParameters.getJobId());
        return false;
    }

}
</pre>
</div>

<p>
在Activity中可以通过LocalBroadcastManager与JobService之间进行通信：
</p>

<div class="org-src-container">

<pre class="src src-java">private BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            log("Job service message received");
        }
    };

public void runCode(View v) {
    JobScheduler jobScheduler = (JobScheduler) getSystemService(
                                                                Context.JOB_SCHEDULER_SERVICE);
    JobInfo jobInfo = new JobInfo.Builder(JOB_ID,
                                          new ComponentName(this, MyJobService.class))
        .setMinimumLatency(0)
        .build();
    jobScheduler.schedule(jobInfo);
}
</pre>
</div>
</div>
</li></ol>
</div>
</div>


<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 安全策略</h3>
<div class="outline-text-3" id="text-1-6">
<p>
在Android中,安全涵盖了应用程序的部署和执行.对于部署来
说,Android应用程序必须被赋予一个数字证书才允许被安装到某个设备中.对
于运行来说,每个应用程序都在一个独立的应用程序中执行,每个进程都有一
个唯一的永久的用户ID(在安装的时候分配的).
</p>

<p>
注册应用程序需要三样东西:
</p>
<ol class="org-ol">
<li>一个数字证书,
</li>
<li>一个.apk文件
</li>
<li>以及用于将数字签名应用到.apk文件的工具(jarsigner).
</li>
</ol>

<p>
注册一个应用程序步骤如下: 
</p>

<ul class="org-ul">
<li>使用Keytool创建一个自注册的证书.
</li>
</ul>
<p>
　　
    步骤1 Create a folder to hold the keystore, for example
</p>
<pre class="example">
c:\android\release\.
</pre>
<p>
　　步骤2 在命名行中执行如下命令:
</p>
<div class="org-src-container">

<pre class="src src-sh">     　　keytool -genkey -v -keystore "FULL PATH OF release.keystore FILE FROM STEP 1"
     　　-alias androidbook -storepass paxxword -keypass paxxword -keyalg RSA
     　　-validity 14000
</pre>
</div>

<p>
keytool的参数说明如下：
<img src="../images/2016/2016070502.png" alt="2016070502.png" />
</p>

<ul class="org-ul">
<li>使用Jarsigner注册.apk文件
<div class="org-src-container">

<pre class="src src-sh">jarsigner -keystore "PATH TO YOUR release.keystore FILE" -storepass paxxword
-keypass paxxword "PATH TO YOUR APK FILE" androidbook(别名)
</pre>
</div>
</li>

<li>用zipalign作字节对齐
命令如下:
<pre class="example">
zipalign –v 4 infile.apk outfile.apk
</pre>

<p>
验证一个.apk文件是否是4字节对齐,用如下命令
</p>
<pre class="example">
zipalign –c –v 4 filename.apk
</pre>
</li>

<li>安装应用程序
<pre class="example">
adb install "PATH TO APK FILE GOES HERE"(安装)
adb uninstall packagename(卸载)
adb install –r "PATH TO APK FILE GOES HERE"(重装)
</pre>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Framework</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Audio System</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Audio System 介绍</h4>
<div class="outline-text-4" id="text-2-1-1">

<div class="figure">
<p><img src="../images/2016/2016053001.png" alt="2016053001.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> AudioTrack 介绍</h4>
<div class="outline-text-4" id="text-2-1-2">

<div class="figure">
<p><img src="../images/2016/2016053002.png" alt="2016053002.png" />
</p>
</div>

<p>
基本说明：
</p>
<ol class="org-ol">
<li>用于管理来自一个Source的Audio 播放将播放的Audio 数据送给
AudioFlinger
</li>
<li>提供播放的控制接口
API:start(), stop(), &#x2026;
</li>
<li>提供Volume 控制接口， 用于控制L/R声道各自的Volume
<ul class="org-ul">
<li>API: setVolume
</li>
<li>Android 体系中有3个Audio Volume控制,  最终的输出Volume是下面3
者的乘积 
<ol class="org-ol">
<li>Master Volume
</li>
<li>Stream Type Volume
</li>
<li>Track Volume
</li>
</ol>
</li>
</ul>
</li>
<li>AudioTrack可以配置为下面三种Mode：
<ol class="org-ol">
<li>PUSH MODE
</li>
<li>PULL MODE
</li>
<li>STATIC MODE
</li>
</ol>
</li>
<li>AudioTrack测试程序
<div class="org-src-container">

<pre class="src src-cpp">/**
 * 利用AudioTrack播放一个wav文件
 */

//#define LOG_NDEBUG 0
#define LOG_TAG "AudioTrackTest"
//#include &lt;utils/Log.h&gt;
#include &lt;media/AudioTrack.h&gt;
#include &lt;system/audio.h&gt;
using namespace android;
#define ALOGD printf
int main(int argc, char *argv[])
{
  int readNum;
  unsigned short channel;
  unsigned int sampleRate;
  FILE *fp = fopen("bzk_chic.wav", "ab+");
  if (fp == NULL) {
    ALOGD("Cannot open .wav file");
    return -1;
  }
  ALOGD("Open wav file successfully!\n");
  fseek(fp, 0x16, 0); 
  readNum= fread(&amp;channel, 1, 2, fp);
  if (readNum &lt; 1) {
    ALOGD("Can not read channel number: %d\n", readNum);
    fclose(fp);
    return 0;
  }
  ALOGD("channel number is %d\n", channel);
  fseek(fp, 0x18, 0); 
  readNum = fread(&amp;sampleRate, 1, 4, fp);
  if (readNum &lt; 1) {
    ALOGD("Cannot read sample rate: %d\n", readNum);
    fclose(fp);
    return 0;
  }
  ALOGD("Sample Rate is %d\n", sampleRate);

  // playing to an AudioTrack, set up mask if necessary
  audio_channel_mask_t audioMask = AUDIO_CHANNEL_OUT_STEREO;
  if (0 == audioMask) {
    return -1;
  }
  sp&lt;AudioTrack&gt; audioTrack = new AudioTrack(
                                             AUDIO_STREAM_MUSIC, sampleRate, AUDIO_FORMAT_PCM_16_BIT, audioMask,
                                             0, AUDIO_OUTPUT_FLAG_NONE);
  status_t status = audioTrack-&gt;initCheck();
  if(status != NO_ERROR) {
    audioTrack.clear();
    ALOGD("Failed for initCheck()");
    return -1;
  }
  audioTrack-&gt;start();

  unsigned char *buffer = new unsigned char[channel * 64 * 2];
  while (1) {
    readNum = fread(buffer, 1, channel * 64 * 2, fp);
    if (readNum &lt;= 0)
      break;
    ALOGD("Write data : %d to AudioTrack", readNum);
    audioTrack-&gt;write(buffer, readNum);
  }

  fclose(fp);
  delete []buffer;
  audioTrack-&gt;stop();

}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> AudioRecord介绍</h4>
<div class="outline-text-4" id="text-2-1-3">

<div class="figure">
<p><img src="../images/2016/2016053003.png" alt="2016053003.png" />
</p>
</div>

<p>
基本说明：
</p>
<ol class="org-ol">
<li>用于管理从底层获取录音数据，并提供给上层
</li>
<li>提供录音的控制接口
API:start(), stop()
</li>
<li>获取声音资料的方式
<ul class="org-ul">
<li>由上层主动调用AudioRecord::read() 来获取数据 (PULL MODE)
</li>
<li>上层提供Callback function, 通过AudioRecord主动将资料通过
Callback 给上层(PUSH MODE) 
</li>
</ul>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4"><span class="section-number-4">2.1.4</span> AudioPolicyService介绍</h4>
<div class="outline-text-4" id="text-2-1-4">

<div class="figure">
<p><img src="../images/2016/2016053004.png" alt="2016053004.png" />
</p>
</div>

<p>
AudioPolicyService在Audio system中的位置和作用
</p>
<ul class="org-ul">
<li>仅是一个行为决策者，而不是行为的实施者
</li>
<li>真正的实施者为AudioFlinger
</li>
<li>它是一个在后台进程中的服务实体，提供的服务就是告诉实施者要怎么去
做
</li>
</ul>


<div class="figure">
<p><img src="../images/2016/2016053005.png" alt="2016053005.png" />
</p>
</div>

<p>
AudioPolicyService几大功能:
</p>
<ul class="org-ul">
<li>设备状态管理
</li>
<li>输入输出策略管理
</li>
<li>音量控制管理
</li>
<li>Effect 控制管理
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-1-5" class="outline-4">
<h4 id="sec-2-1-5"><span class="section-number-4">2.1.5</span> AudioFlinger</h4>
<div class="outline-text-4" id="text-2-1-5">

<div class="figure">
<p><img src="../images/2016/2016053006.png" alt="2016053006.png" />
</p>
</div>

<p>
AudioFlinger的线程循环逻辑如下所示：
</p>


<div class="figure">
<p><img src="../images/2016/2016053007.png" alt="2016053007.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Media Framework</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 基础知识</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
AMessage代表一个消息，对应一个target， 根据这个target可以知道对
应的消息应该归哪个AHandler去处理。
</p>

<p>
AHandler是处理消息的基类，它有一个id，处理与这个id相关联的AMessage，
在 <code>onMessageReceived</code> 函数中处理各种消息。
从AHandler派生的类，都会重写该方法，以处理各种消息。
</p>

<p>
有一个全局的 <code>ALooperRoster</code> 对象，它维护了系统中存在的 AHandler对
象。
</p>

<p>
ALooper对象，通过 <code>registerHandler</code> 接口将AHandler对象注册给
<code>ALooperRoster</code> 对象维护的AHandler列表中。
</p>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 主要代码路径</h4>
<div class="outline-text-4" id="text-2-2-2">
</div><ol class="org-ol"><li><a id="sec-2-2-2-1" name="sec-2-2-2-1"></a>MediaPlayer.java<br  /><div class="outline-text-5" id="text-2-2-2-1">
<ul class="org-ul">
<li>Java 层的 MediaPlayer 接口，APK 主要通过 call 它的接口实现播放功能
</li>
<li>code path: framework/base/media/java/android/media/MediaPlayer.java
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-2-2" name="sec-2-2-2-2"></a>Media JNI<br  /><div class="outline-text-5" id="text-2-2-2-2">
<ul class="org-ul">
<li>MediaPlayer java 层与 native 层的接口
</li>
<li>code path: framework/base/media/jni/android_media_MediaPlayer.cpp
</li>
<li>output:libmedia_jni.so
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-2-3" name="sec-2-2-2-3"></a>MediaPlayer<br  /><div class="outline-text-5" id="text-2-2-2-3">
<ul class="org-ul">
<li>MediaPlayer Native 层 client 端接口
</li>
<li>code path: framework/av/media/libmedia/
</li>
<li>output:libmedia.so
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-2-4" name="sec-2-2-2-4"></a>Media Service<br  /><div class="outline-text-5" id="text-2-2-2-4">
<ul class="org-ul">
<li>Native 层真正实现播放功能的 Service 进程
</li>
<li>code path:
framework/av/media/mediaserver
framework/av/media/libmediaplayerservice
</li>
<li>output: mediaserver   libmediaplayerservice.so
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> Stagefright</h4>
<div class="outline-text-4" id="text-2-2-3">
</div><ol class="org-ol"><li><a id="sec-2-2-3-1" name="sec-2-2-3-1"></a>StagefrightPlayer<br  /><div class="outline-text-5" id="text-2-2-3-1">
<ul class="org-ul">
<li>负责提供 player 的接口
</li>
<li>code path: framework/av/media/libmediaplayerservice/StagefrightPlayer.cpp
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-3-2" name="sec-2-2-3-2"></a>AwesomePlayer<br  /><div class="outline-text-5" id="text-2-2-3-2">
<ul class="org-ul">
<li>真正实现 playback 功能的模块
</li>
<li>code path: : framework/av/media/libstagefright
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-3-3" name="sec-2-2-3-3"></a>DataSource<br  /><div class="outline-text-5" id="text-2-2-3-3">
<ul class="org-ul">
<li>提供 Source 数据，可以是本地文件，也可以是网络数据
</li>
<li>code path: : framework/av/media/libstagefright
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-3-4" name="sec-2-2-3-4"></a>MediaSource<br  /><div class="outline-text-5" id="text-2-2-3-4">
<ul class="org-ul">
<li>MediaSource使用到了DataSoure和OMX，可以提供解码后的供显示的数据
</li>
<li>code path: framework/av/media/libstagefright/
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-3-5" name="sec-2-2-3-5"></a>OMXClient<br  /><div class="outline-text-5" id="text-2-2-3-5">
<ul class="org-ul">
<li>使用 OMX 的 client 端
</li>
<li>code path: framework/av/media/libstagefright/
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-3-6" name="sec-2-2-3-6"></a>OMX<br  /><div class="outline-text-5" id="text-2-2-3-6">
<ul class="org-ul">
<li>提供一套接口接到底层的 decoder 进行解码
</li>
<li>code path: framework/av/media/libstagefright/omx
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> NuPlayer</h4>
<div class="outline-text-4" id="text-2-2-4">

<div class="figure">
<p><img src="../images/2016/2016053008.png" alt="2016053008.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> OpenMAX</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
OpenMAX is a royalty-free, cross-platform API. OpenMAX Working
Group has been formed by the Khronos Group. The Standard for Media
Library Portability. Reduce the cost and complexity of porting
multimedia software to  new processors and architectures. 分为
OpenMAX DL, IL, AL 三层，Android 上只用到 OpenMAX IL. 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Graphics</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> Android Graphics Pipeline Overview</h4>
<div class="outline-text-4" id="text-2-3-1">
</div><ol class="org-ol"><li><a id="sec-2-3-1-1" name="sec-2-3-1-1"></a>Android Graphics Pipeline<br  /><div class="outline-text-5" id="text-2-3-1-1">

<div class="figure">
<p><img src="../images/2016/2016052601.png" alt="2016052601.png" />
</p>
</div>

<p>
如图，对于一些Buffer，有些通过GPU处理后，再送给HWComposer，有些则
直接送给HWComposer处理。
</p>
</div>
</li>

<li><a id="sec-2-3-1-2" name="sec-2-3-1-2"></a>BufferQueue<br  /><div class="outline-text-5" id="text-2-3-1-2">

<div class="figure">
<p><img src="../images/2016/2016052602.png" alt="2016052602.png" />
</p>
</div>

<p>
关于BufferQueue的说明如下：
</p>
<ol class="org-ol">
<li>manages flow of buffers between producers and consumers
</li>
<li>two queues
</li>
<li>producers dequeue unused buffers, fill them, then queue them
</li>
<li>consumers acquire filled buffers, use them, then release them
when done.
</li>
</ol>
</div>
</li>

<li><a id="sec-2-3-1-3" name="sec-2-3-1-3"></a>SurfaceFlinger<br  /><div class="outline-text-5" id="text-2-3-1-3">
<p>
它的主要使用是：
</p>
<ol class="org-ol">
<li>Responsible for compositing all windows into the display(s)
</li>
<li>Just another GL client
</li>
</ol>
</div>
</li>

<li><a id="sec-2-3-1-4" name="sec-2-3-1-4"></a>HW Composer<br  /><div class="outline-text-5" id="text-2-3-1-4">
<p>
一开始是为了加速叠图而准备的一个HAL，目前作为所有显示的HAL。
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-3-1-4-1" name="sec-2-3-1-4-1"></a>Overlay<br  /><ol class="org-ol"><li><a id="sec-2-3-1-4-1-1" name="sec-2-3-1-4-1-1"></a>Overlay 是什么<br  /><div class="outline-text-7" id="text-2-3-1-4-1-1">
<p>
在android 上面，屏幕上输出的画面都是由多个图层（layer）合成
（compsing）得到的结果. 所以在android上面，图像的合成是非常普
通而且常见(频繁)的操作, 如果有一个简单而省电的hardware(hw)来负
责图像合成, 可以很有效的降低功耗,而且也可以降低GPU的loading.
</p>

<p>
Overlay 就是一个专门负责图像合成的一个hw. 相比GPU 而言,
overlay 是一个非常简单图像处理hw. 和GPU具有的庞大的图形功能不
同, overlay只能负责简单的图像合成动作.
</p>

<p>
由于overlay 功能简单,所以hw的实现上相比GPU也要简单很多,工作起
来也会非常省电.
</p>
</div>
</li>


<li><a id="sec-2-3-1-4-1-2" name="sec-2-3-1-4-1-2"></a>Overlay 有什么限制<br  /><div class="outline-text-7" id="text-2-3-1-4-1-2">
<p>
由于overlay hw很简单，所以它只能处理简单的图像合成工作，太复杂
的图像合成工作还是要GPU来协助完成.
</p>

<p>
overlay 无法处理的case：
</p>
<ol class="org-ol">
<li>需要旋转的图像
</li>
<li>需要缩放的图像
</li>
<li>图层超过4层
</li>
</ol>

<p>
不过对于普通的android应用场景来说,很少会出现上述的那些cases.
</p>
</div>
</li>

<li><a id="sec-2-3-1-4-1-3" name="sec-2-3-1-4-1-3"></a>没有overlay HW，图像合成流程<br  /><div class="outline-text-7" id="text-2-3-1-4-1-3">
<p>
Surfaceflinger把需要合成的layers 交给GPU 做composing, 最终输出
到屏幕。
</p>


<div class="figure">
<p><img src="../images/2016/2016071204.png" alt="2016071204.png" />
</p>
</div>
</div>
</li>


<li><a id="sec-2-3-1-4-1-4" name="sec-2-3-1-4-1-4"></a>有Overlay HW, 图像合成的流程<br  /><div class="outline-text-7" id="text-2-3-1-4-1-4">
<p>
Surfaceflinger把需要合成的layers 交给ovl做composing, 最终输出
到屏幕。
</p>


<div class="figure">
<p><img src="../images/2016/2016071205.png" alt="2016071205.png" />
</p>
</div>
</div>
</li>

<li><a id="sec-2-3-1-4-1-5" name="sec-2-3-1-4-1-5"></a>有overlay HW,但需要GPU做图像合成流程<br  /><div class="outline-text-7" id="text-2-3-1-4-1-5">
<p>
Overlay不能处理的layers, 会交给GPU做图像合成，GPU把图像合成为
一个layer, 然后再通过overlay 输出.
</p>


<div class="figure">
<p><img src="../images/2016/2016071206.png" alt="2016071206.png" />
</p>
</div>
</div>
</li></ol>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> Android Sync Framework</h4>
<div class="outline-text-4" id="text-2-3-2">
</div><ol class="org-ol"><li><a id="sec-2-3-2-1" name="sec-2-3-2-1"></a>定义<br  /><div class="outline-text-5" id="text-2-3-2-1">
<p>
Synchronization between consumers and producers who are from
different hardware components to use a buffer atomically
</p>
</div>
</li>

<li><a id="sec-2-3-2-2" name="sec-2-3-2-2"></a>应用背景<br  /><div class="outline-text-5" id="text-2-3-2-2">
<p>
在复杂的DMA管线如图形管线（多媒体，摄像头，GPU以及显示设备），一
个buffer的消费者需要知道生产者什么时候完成生产（即创建一个Buffer,
并往里面放置消费者所需要的数据）。同样地，生产者也需要知道消费者
什么时候使用它创建的Buffer，以便它可以重新使用这个Buffer。而且，
一个Buffer可能被多个不同的消费者使用不同的时间。另外，一个消费者
可能需要互斥地消费多个Buffer，等等，有一个问题应运而生，就是如何
保证多个消费者之间同步使用Buffer，以及生产者与消费者协调使用
Buffer。因为Buffer是一个共享资源，且任何消费者或生产者对Buffer的
使用都是排他性的（因为它们属于不同的硬件单元或模块），大体看来，
需要解决如下两个问题：
</p>
<ol class="org-ol">
<li>消费者与生产者之间对Buffer的同步访问。
</li>
<li>消费者之间对Buffer的同步访问。
</li>
</ol>
</div>
</li>

<li><a id="sec-2-3-2-3" name="sec-2-3-2-3"></a>目标<br  /><div class="outline-text-5" id="text-2-3-2-3">
<ol class="org-ol">
<li>Provide a simple API to let components signal when buffers are
ready/released.
</li>
<li>Allow synchronization primitives to be passed between processes
and between userspace and the kernel.
</li>
<li>Allow implementers to exploit hardware sync support
</li>
<li>Provide visibility into the graphics pipeline for debugging
</li>
</ol>
</div>
</li>

<li><a id="sec-2-3-2-4" name="sec-2-3-2-4"></a>Software Stacks<br  /><div class="outline-text-5" id="text-2-3-2-4">

<div class="figure">
<p><img src="../images/2016/2016052609.png" alt="2016052609.png" />
</p>
</div>
</div>
</li>

<li><a id="sec-2-3-2-5" name="sec-2-3-2-5"></a>实现<br  /><div class="outline-text-5" id="text-2-3-2-5">
<ol class="org-ol">
<li>sync_timeline


<div class="figure">
<p><img src="../images/2016/2016052603.png" alt="2016052603.png" />
</p>
</div>

<ul class="org-ul">
<li>Represents monotonically increasing counter
</li>

<li>Generally one instance per driver context
</li>

<li>allows hardware specific implementation
</li>

<li>sw_sync implementation provided
</li>
</ul>
</li>

<li>sync_pt


<div class="figure">
<p><img src="../images/2016/2016052604.png" alt="2016052604.png" />
</p>
</div>

<ul class="org-ul">
<li>Represents a specific values on a parent timeline
</li>

<li>3 states
<ul class="org-ul">
<li>active
</li>

<li>signaled
</li>

<li>error
</li>
</ul>
</li>

<li>starts active and transitions once to either signaled or
error
</li>
</ul>
</li>

<li>sync_fence


<div class="figure">
<p><img src="../images/2016/2016052605.png" alt="2016052605.png" />
</p>
</div>

<ul class="org-ul">
<li>A collection of sync_pts
</li>

<li>Backed by a file and can be passed to userspace.
</li>

<li>Main primitive drivers and userspace use to describe sync
events/dependencies.
</li>

<li>Fences are a promise by the kernel
<ul class="org-ul">
<li>that work has been queued
</li>

<li>and will complete in a "timely" manner
</li>
</ul>
</li>

<li>Starts active and transitions to signaled with all of its
sync_pts become signaled or one becomes errored
</li>

<li>The list of sync_pts is immutable after fence creation
</li>

<li>A sync_pt can only be in one fence.
</li>

<li>Two fences can be merged to create a third fence containing
copies of the sync points in both.
</li>

<li>Sync Merge

<ul class="org-ul">
<li>Before Merge


<div class="figure">
<p><img src="../images/2016/2016052606.png" alt="2016052606.png" />
</p>
</div>
</li>

<li>After Merge


<div class="figure">
<p><img src="../images/2016/2016052607.png" alt="2016052607.png" />
</p>
</div>
</li>
</ul>
</li>
</ul>
</li>

<li>代码

<ul class="org-ul">
<li>supported in android-3.10 kernel + staged for quite some
time
</li>

<li>Core

<ul class="org-ul">
<li><code>drivers/staging/android/sync.c</code>
</li>

<li><code>drivers/staging/android/sync.h</code>
</li>
</ul>
</li>

<li>sw_sync

<ul class="org-ul">
<li><code>drivers/staging/android/sw_sync.c</code>
</li>

<li><code>drivers/staging/android/sw_sync.h</code>
</li>
</ul>
</li>

<li>接口声明


<div class="figure">
<p><img src="../images/2016/2016052608.png" alt="2016052608.png" />
</p>
</div>
</li>
</ul>
</li>

<li>实现sync_timeline的建议

<p>
在实现前，先考虑是否可以直接使用sw_sync, 以sw_sync为起点。
</p>
<ul class="org-ul">
<li>Don'ts
<ul class="org-ul">
<li>Don't base a timeline on any "real" time.
</li>

<li>Don't allow userspace to explicitly
<ul class="org-ul">
<li>create a fence
</li>

<li>signal a fence
</li>
</ul>
</li>

<li>Don't access sync_timeline, sync_pt, or sync_fence
            elements explicitly.
</li>
</ul>
</li>

<li>Dos
<ul class="org-ul">
<li>Do provide useful names
</li>

<li>Do implement timeline_value str and pt_value_str
</li>

<li>Do implement fill driver_data
</li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Input System</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Input  Event Process Flow
</p>


<div class="figure">
<p><img src="../images/2016/2016053009.png" alt="2016053009.png" />
</p>
</div>
</div>


<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> Architecture (ICS)</h4>
<div class="outline-text-4" id="text-2-4-1">

<div class="figure">
<p><img src="../images/2016/2016053010.png" alt="2016053010.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Architecture (JB)</h4>
<div class="outline-text-4" id="text-2-4-2">

<div class="figure">
<p><img src="../images/2016/2016053011.png" alt="2016053011.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Wifi Framework</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Android L中Framework为了保证设备在移动过程中，能够连接到新的AP，
针对不支持Background Scan的设备，在WifiStateMachine中定义了一个
变量 <code>mDefaultFrameworkScanIntervalMs</code> ，默认初始化为
<code>config_wifi_framework_scan_interval</code> , 这个值是在
<code>frameworks\base\core\res\res\values\config.xml</code> 文件中定义的，默
认值为 30s。 
</p>

<p>
学习计划：
</p>
<ol class="org-ol">
<li>先按顺序分析每个类
</li>
<li>总结重点流程
</li>
</ol>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> Common</h4>
<div class="outline-text-4" id="text-2-5-1">
</div><ol class="org-ol"><li><a id="sec-2-5-1-1" name="sec-2-5-1-1"></a>WifiMonitor<br  /></li>

<li><a id="sec-2-5-1-2" name="sec-2-5-1-2"></a>WifiNative<br  /></li>

<li><a id="sec-2-5-1-3" name="sec-2-5-1-3"></a>WifiNetworkScoreCache<br  /></li>

<li><a id="sec-2-5-1-4" name="sec-2-5-1-4"></a>WifiParser<br  /></li>

<li><a id="sec-2-5-1-5" name="sec-2-5-1-5"></a>WifiSettingsStore<br  /></li>

<li><a id="sec-2-5-1-6" name="sec-2-5-1-6"></a>WifiConfigStore<br  /></li>

<li><a id="sec-2-5-1-7" name="sec-2-5-1-7"></a>WifiApConfigStore<br  /><div class="outline-text-5" id="text-2-5-1-7">
<p>
存储热点的信息：
主要包含：SSID， KeyMgmt， 以及ShareKey。
配置文件路径："/data/misc/wifi/softap.conf"
</p>
</div>
</li>

<li><a id="sec-2-5-1-8" name="sec-2-5-1-8"></a>WifiTrafficPoller<br  /></li>

<li><a id="sec-2-5-1-9" name="sec-2-5-1-9"></a>WifiWatchdogStateMachine<br  /></li>

<li><a id="sec-2-5-1-10" name="sec-2-5-1-10"></a>WifiAutoJoinController<br  /></li>

<li><a id="sec-2-5-1-11" name="sec-2-5-1-11"></a>SupplicantStateTracker<br  /></li>

<li><a id="sec-2-5-1-12" name="sec-2-5-1-12"></a>RttManager<br  /></li></ol>
</div>

<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> 传统WiFi</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
Android Framework中的wifi代码分为两部分，一部分面向应用开发者，提供
公共接口给应用开发者，另一部分则是框架的实现灵魂，代码分别位于：
Android 5.1
</p>
<ul class="org-ul">
<li>frameworks\base\wifi\java\android\net\wifi
</li>
<li>frameworks\opt\net\wifi\service
</li>
</ul>
</div>

<ol class="org-ol"><li><a id="sec-2-5-2-1" name="sec-2-5-2-1"></a>WifiScanningServiceImpl<br  /></li>

<li><a id="sec-2-5-2-2" name="sec-2-5-2-2"></a>Scan周期<br  /><div class="outline-text-5" id="text-2-5-2-2">
<p>
<code>config_wifi_supplicant_scan_interval</code>  
<code>config_wifi_framework_enable_associated_autojoin_scan</code>  关联
后是否允许扫描
</p>
</div>
</li>

<li><a id="sec-2-5-2-3" name="sec-2-5-2-3"></a>无网络时的行为<br  /><div class="outline-text-5" id="text-2-5-2-3">
<p>
当系统没有连接上任何网络时，且没有保存过的网络信息时，，这个命令
<code>CMD_NO_NETWORKS_PERIODIC_SCAN</code> 会执行一个周期性的扫描来通
知用户当前有哪些开放网络。
</p>
</div>
</li>

<li><a id="sec-2-5-2-4" name="sec-2-5-2-4"></a>WifiServiceImpl<br  /></li>

<li><a id="sec-2-5-2-5" name="sec-2-5-2-5"></a>代码实例<br  /><div class="outline-text-5" id="text-2-5-2-5">
<ol class="org-ol">
<li>Connect to Wi-Fi with WEP encryption
<div class="org-src-container">

<pre class="src src-java">public boolean ConnectToNetworkWEP( String networkSSID, String password )
{
    try {
        WifiConfiguration conf = new WifiConfiguration();
        conf.SSID = "\"" + networkSSID + "\"";   // Please note the quotes. String should contain SSID in quotes
        conf.wepKeys[0] = "\"" + password + "\""; //Try it with quotes first

        conf.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        conf.allowedGroupCiphers.set(WifiConfiguration.AuthAlgorithm.OPEN);
        conf.allowedGroupCiphers.set(WifiConfiguration.AuthAlgorithm.SHARED);


        WifiManager wifiManager = (WifiManager) this.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        int networkId = wifiManager.addNetwork(conf);

        if (networkId == -1){
            //Try it again with no quotes in case of hex password
            conf.wepKeys[0] = password;
            networkId = wifiManager.addNetwork(conf);
        }

        List&lt;WifiConfiguration&gt; list = wifiManager.getConfiguredNetworks();
        for( WifiConfiguration i : list ) {
            if(i.SSID != null &amp;&amp; i.SSID.equals("\"" + networkSSID + "\"")) {
                wifiManager.disconnect();
                wifiManager.enableNetwork(i.networkId, true);
                wifiManager.reconnect();
                break;
            }
        }

        //WiFi Connection success, return true
        return true;
    } catch (Exception ex) {
        System.out.println(Arrays.toString(ex.getStackTrace()));
        return false;
    }
}
</pre>
</div>
</li>

<li>Connect to Wi-Fi with WPA2 encryption
<div class="org-src-container">

<pre class="src src-java">public boolean ConnectToNetworkWPA( String networkSSID, String password ) {
  try {
    WifiConfiguration conf = new WifiConfiguration();
    conf.SSID = "\"" + networkSSID + "\"";   // Please note the quotes. String should contain SSID in quotes

    conf.preSharedKey = "\"" + password + "\"";

    conf.status = WifiConfiguration.Status.ENABLED;
    conf.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
    conf.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
    conf.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
    conf.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
    conf.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);

    Log.d("connecting", conf.SSID + " " + conf.preSharedKey);

    WifiManager wifiManager = (WifiManager) this.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
    wifiManager.addNetwork(conf);

    Log.d("after connecting", conf.SSID + " " + conf.preSharedKey);



    List&lt;WifiConfiguration&gt; list = wifiManager.getConfiguredNetworks();
    for( WifiConfiguration i : list ) {
      if(i.SSID != null &amp;&amp; i.SSID.equals("\"" + networkSSID + "\"")) {
        wifiManager.disconnect();
        wifiManager.enableNetwork(i.networkId, true);
        wifiManager.reconnect();
        Log.d("re connecting", i.SSID + " " + conf.preSharedKey);

        break;
      }
    }


    //WiFi Connection success, return true
    return true;
  } catch (Exception ex) {
    System.out.println(Arrays.toString(ex.getStackTrace()));
    return false;
  }
}
</pre>
</div>
</li>
</ol>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-5-3" class="outline-4">
<h4 id="sec-2-5-3"><span class="section-number-4">2.5.3</span> P2P/Miracast</h4>
<div class="outline-text-4" id="text-2-5-3">
</div><ol class="org-ol"><li><a id="sec-2-5-3-1" name="sec-2-5-3-1"></a>WifiP2pServiceImpl<br  /><div class="outline-text-5" id="text-2-5-3-1">
<p>
连接一个 p2p设备的大致调用序列是(WifiP2pManager)：
</p>
<ol class="org-ol">
<li>discoverPeers()
主要是下p2p find命令，打到对端设备的一些 信息
</li>
<li>connect()
这个函数调用涉及到GO协商， WPS交互， 关联以及4步握手过程
直到p2p GO/GC设备连接成功。
</li>
</ol>

<p>
示例代码：
</p>
<div class="org-src-container">

<pre class="src src-java">/**
 * A base class for connection request test.
 */
public abstract class ConnectReqTestCase extends ReqTestCase {

   protected P2pBroadcastReceiverTest mReceiverTest;

   public ConnectReqTestCase(Context context) {
       super(context);
   }

   /**
    * Set up the test case.
    */
   protected void setUp() {
       super.setUp();
       mReceiverTest = new P2pBroadcastReceiverTest(mContext);
       mReceiverTest.init(mChannel);

       try {
           Method[] methods = WifiP2pManager.class.getMethods();
           for (int i = 0; i &lt; methods.length; i++) {
               if (methods[i].getName().equals("deletePersistentGroup")) {
                   // Delete any persistent group
                   for (int netid = 0; netid &lt; 32; netid++) {
                       methods[i].invoke(mP2pMgr, mChannel, netid, null);
                   }
               }
           }
       } catch(Exception e) {
           e.printStackTrace();
       }
       // Disconnect from wifi to avoid channel conflict
       mWifiMgr.disconnect();
   }

   /**
    * Tear down the test case.
    */
   protected void tearDown() {
       super.tearDown();
       if (mReceiverTest != null) {
           mReceiverTest.close();
       }
       if (mP2pMgr != null) {
           mP2pMgr.cancelConnect(mChannel, null);
           mP2pMgr.removeGroup(mChannel, null);
       }
   }

   /**
    * Tries to connect the target devices.
    * @param isJoin if true, try to join the group. otherwise, try go negotiation.
    * @param wpsConfig wps configuration method.
    * @return true if succeeded.
    * @throws InterruptedException
    */
   protected boolean connectTest(boolean isJoin, int wpsConfig) throws InterruptedException {
       notifyTestMsg(R.string.p2p_searching_target);

       /*
        * Search target device and check its capability.
        */
       ActionListenerTest actionListener = new ActionListenerTest();
       mP2pMgr.discoverPeers(mChannel, actionListener);
       if (!actionListener.check(ActionListenerTest.SUCCESS, TIMEOUT)) {
           mReason = mContext.getString(R.string.p2p_discover_peers_error);
           return false;
       }

        WifiP2pDevice dev = mReceiverTest.waitDeviceFound(mTargetAddress, TIMEOUT);
        if (dev == null) {
            mReason = mContext.getString(R.string.p2p_target_not_found_error);
            return false;
        }

        if (!isJoin &amp;&amp; dev.isGroupOwner()) {
            // target device should be p2p device.
            mReason = mContext.getString(R.string.p2p_target_invalid_role_error);
            return false;
        } else if (isJoin &amp;&amp; !dev.isGroupOwner()) {
            //target device should be group owner.
            mReason = mContext.getString(R.string.p2p_target_invalid_role_error2);
            return false;
        }

        if (wpsConfig == WpsInfo.PBC) {
            notifyTestMsg(R.string.p2p_connecting_with_pbc);
        } else {
            notifyTestMsg(R.string.p2p_connecting_with_pin);
        }

        /*
         * Try to connect the target device.
         */
        WifiP2pConfig config = new WifiP2pConfig();
        config.deviceAddress = dev.deviceAddress;
        config.wps.setup = wpsConfig;
        mP2pMgr.connect(mChannel, config, actionListener);
        if (!actionListener.check(ActionListenerTest.SUCCESS, TIMEOUT)) {
            mReason = mContext.getString(R.string.p2p_connect_error);
            return false;
        }

        /*
         * Check if the connection broadcast is received.
         */
        WifiP2pInfo p2pInfo = mReceiverTest.waitConnectionNotice(TIMEOUT_FOR_USER_ACTION);
        if (p2pInfo == null) {
            mReason = mContext.getString(R.string.p2p_connection_error);
            return false;
        }

        /*
         * Wait until peer gets marked conencted.
         */
        notifyTestMsg(R.string.p2p_waiting_for_peer_to_connect);
        if (mReceiverTest.waitPeerConnected(mTargetAddress, TIMEOUT) != true) {
            mReason = mContext.getString(R.string.p2p_connection_error);
            return false;
        }

        /*
         * Remove the p2p group manualy.
         */
        mP2pMgr.removeGroup(mChannel, actionListener);
        if (!actionListener.check(ActionListenerTest.SUCCESS, TIMEOUT)) {
            mReason = mContext.getString(R.string.p2p_remove_group_error);
            return false;
        }

        notifyTestMsg(R.string.p2p_waiting_for_peer_to_disconnect);

        /*
         * Check if p2p disconnection broadcast is received
         */
        p2pInfo = mReceiverTest.waitDisconnectionNotice(TIMEOUT);
        if (p2pInfo == null) {
            mReason = mContext.getString(R.string.p2p_connection_error);
            return false;
        }

        /* Wait until peer gets marked disconnected */

        if (mReceiverTest.waitPeerDisconnected(mTargetAddress, TIMEOUT) != true) {
            mReason = mContext.getString(R.string.p2p_detect_disconnection_error);
            return false;
        }

        return true;
    }
}
</pre>
</div>

<p>
这个时候，对端设备会弹出Invitation to connect 的提示框，点击
接受后，会向wifi p2p状态机发送 <code>PEER_CONNECTION_USER_ACCEPT</code>
消失。 （notifyInvitationReceived）
</p>

<p>
事实上，Wifi p2p 状态机在收到如下几个事件时，都会弹出确认对
话框：
</p>
<ul class="org-ul">
<li><code>P2P_PROV_DISC_PBC_REQ_EVENT</code>
</li>
<li><code>P2P_PROV_DISC_ENTER_PIN_EVENT</code>
</li>
<li><code>P2P_PROV_DISC_SHOW_PIN_EVENT</code>
</li>
<li><code>P2P_GO_NEGOTIATION_REQUEST_EVENT</code>
</li>
<li><code>P2P_INVITATION_RECEIVED_EVENT</code>
</li>
</ul>
</div>
</li>

<li><a id="sec-2-5-3-2" name="sec-2-5-3-2"></a>开启WifiSink的调用序列<br  /><div class="outline-text-5" id="text-2-5-3-2">
<p>
DisplayManager.requestEnableSink
DisplayManager.enableSink
DisplayManagerGlobal.enableSink
DisplayManagerService.enableSink
DisplayManagerService.enableSinkInternal
WifiDisplayAdapter.requestEnableSinkLocked
WifiDisplayController.requestEnableSink
</p>


<p>
WifiDisplaySinkActivity
WfdSinkSurfaceFragment
WfdSinkExt.setupWfdSinkConnection
WfdSinkExt.setWfdMode(true)
WifiDisplayAdapter.requestEnableSinkLocked
&#x2026;
WifiDisplayController.startWaitConnection
WifiDisplayController.enterSinkState
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-5-4" class="outline-4">
<h4 id="sec-2-5-4"><span class="section-number-4">2.5.4</span> SoftAp</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
NetworkManagementService服务启动hostapd
WifiStateMachine在InitialState中收到 <code>CMD_START_AP</code> ， 
变量 mWifiApState跟踪了SoftAp的状态
</p>

<p>
调用流程：
WifiManager.setWifiApEnabled
-&gt; WifiServiceImpl.setWifiApEnabled : Send CMD_SET_AP to WifiController
-&gt; WifiController 在ApDisabledState处理上述消息，调用
WifiStateMachine.setHostApRunning
-&gt; WifiStateMachine向自己发送 CMD_START_AP
-&gt; startSoftApWithConfig最终调用NetworkManagerService的
startAccessPoint
</p>



<div class="figure">
<p><img src="../images/2016/2016090501.png" alt="2016090501.png" />
</p>
</div>


<p>
WifiStateMachine与SoftAp相关的状态为：
   addState(mSoftApStartingState, mDefaultState);
   addState(mSoftApStartedState, mDefaultState);
       addState(mTetheringState, mSoftApStartedState);
       addState(mTetheredState, mSoftApStartedState);
       addState(mUntetheringState, mSoftApStartedState);
</p>
</div>
</div>

<div id="outline-container-sec-2-5-5" class="outline-4">
<h4 id="sec-2-5-5"><span class="section-number-4">2.5.5</span> 主要流程总结</h4>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Global Settings</h3>
<div class="outline-text-3" id="text-2-6">
<p>
设置和访问一个全局变量。
</p>
</div>

<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1"><span class="section-number-4">2.6.1</span> Settings.java</h4>
<div class="outline-text-4" id="text-2-6-1">
<div class="org-src-container">

<pre class="src src-java">//frameworks/base/core/java/android/provider/Settings.java
public final class Settings {
    public static final String WIFI_AUTO_CONNECT = "wifi_auto_connect";
    ...
    MOVED_TO_GLOBAL.add(Settings.Global.WIFI_AUTO_CONNECT);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2"><span class="section-number-4">2.6.2</span> defaults.xml</h4>
<div class="outline-text-4" id="text-2-6-2">
<div class="org-src-container">

<pre class="src src-xml">&lt;!--framework/bas /packages/SettingsProvider/res/values/defaults.xml --&gt;
&lt;integer name="def_wifi_auto_connect"&gt;0&lt;/integer&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6-3" class="outline-4">
<h4 id="sec-2-6-3"><span class="section-number-4">2.6.3</span> DatabaseHelper.java</h4>
<div class="outline-text-4" id="text-2-6-3">
<div class="org-src-container">

<pre class="src src-java">public class DatabaseHelper extends SQLiteOpenHelper {
    ...
    loadIntegerSetting(stmt, Settings.Global.WIFI_AUTO_CONNECT,
                       R.integer.def_wifi_auto_connect);

    ...
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6-4" class="outline-4">
<h4 id="sec-2-6-4"><span class="section-number-4">2.6.4</span> 访问</h4>
<div class="outline-text-4" id="text-2-6-4">
<div class="org-src-container">

<pre class="src src-java">//读取
Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.WIFI_AUTO_CONNECT);
//写入
Settings.Global.putInt(getContentResolver(), Settings.Global.WIFI_AUTO_CONNECT, 0);
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Android 8.0 architecture</h2>
<div class="outline-text-2" id="text-3">
<p>
An Android device includes the following partitions:
</p>


<div class="figure">
<p><img src="../images/2018/2018091601.png" alt="2018091601.png" />
</p>
<p><span class="figure-number">Figure 26:</span> Android partitions.</p>
</div>

<ul class="org-ul">
<li>system.img

<p>
Contains mainly Android framework.
</p>
</li>

<li>boot.img

<p>
(kernel/ramdisk) Contains Linux kernel + Android patches.
</p>
</li>

<li>vendor.img

<p>
Contains SoC-specific code and configurations.
</p>
</li>

<li>odm.img

<p>
Contains device-specific code and configurations.
</p>
</li>

<li>oem.img

<p>
Contains OEM/carrier-related configurations and customizations.
</p>
</li>

<li>bootloader

<p>
Brings up the kernel (vendor-proprietary).
</p>
</li>

<li>radio

<p>
Modem (proprietary).
</p>
</li>
</ul>

<p>
Prior to Android 8.0, the vendor , odm , and oem images were optional ; files belonging to
these images were placed in boot.img or system.img with symlinks (such as /vendor &gt;
/system/vendor ) when absent. Android 8.0 makes the vendor partition
mandatory .
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Fu Yajun</p>
<p class="date">Created: 2019-04-11 Thu 13:58</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.0.50.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
