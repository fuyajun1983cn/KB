<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>我的Android技术文章</title>
<!-- 2018-09-12 Wed 17:38 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Fu Yajun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">我的Android技术文章</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 编写native activity</a></li>
<li><a href="#sec-2">2. Binder通信过程中的结点管理</a></li>
<li><a href="#sec-3">3. Looper类代码分析</a></li>
<li><a href="#sec-4">4. Android Region代码分析</a></li>
<li><a href="#sec-5">5. Binder通信过程中的用户空间线程池的管理</a></li>
<li><a href="#sec-6">6. Binder通信相关的类简要分析</a></li>
<li><a href="#sec-7">7. Binder结点管理</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 编写native activity</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>android/native_activity.h</code> 提供的本地活动接口是基于应用程序提供的
一系列回调函数, 这些回调函数将在相应事件发生，在活动的主线程中调用，
所以这些回调函数不能阻塞。
</p>

<p>
理论上，我们只要编写相应的回调函数就可以了，方法简单， 直接了当，但
是，非常受限（因为在主线程中直接执行，会阻塞主线程）。为了解决这种
限制， <b>NDK</b> 包中提供了 <code>android_native_app_glue</code> 库，采用多线程方式，允许
应用程序在不同的线程上实现自己的主事件循环，它的要求如下：
</p>
<ol class="org-ol">
<li>应用程序必须提供一个称为 <code>android_main()</code> 的函数，它将在活动创建时
被调用。它是单独开启一个线程执行的，不在活动的主线程里面。
</li>
<li><code>android_main()</code> 接受一个合法的 <code>android_app</code> 结构体指针，它包含
了对其他重要对象的引用，如应用程序运行于其中的ANativeActivity对
象实例。
</li>
<li><code>android_app</code> 对象拥有一个ALooper实例，它已经监听了两个重要的事件：
<ul class="org-ul">
<li>活动生命周期事件（如“暂停”，“恢复”）。
<pre class="example">
ALooper_pollOnce：LOOPER_ID_MAIN
</pre>
</li>
<li>来自于依附于当前活动的AInputQueue的事件。
<pre class="example">
ALooper_pollOnce：LOOPER_ID_INPUT
</pre>
<p>
可以监听发生在其他的文件描述符上的事件，可以使用回调方式或设置
indent值为 <code>LOOPER_ID_USER</code> 
</p>
<pre class="example">
ALooper_addFd（...）
</pre>
</li>
</ul>
</li>
<li>任何时候，收到 <code>LOOPER_ID_MAIN</code> 或 <code>LOOPER_ID_INPUT</code> 事件，返回的数
据是一个指向 <code>android_poll_source</code> 的结构体指针。可以调用它的 <code>process()</code>
函数，并在其中回调 <code>android_app-&gt;onAppCmd</code> 和 <code>android_app-&gt;onInputEvent</code>
处理应用程序相关的事件。当然，也可以调用底层的函数直接读取和处理
数据。


<div class="figure">
<p><img src="../images/2016/2016070501.png" alt="2016070501.png" />
</p>
<p><span class="figure-number">Figure 1:</span> 函数调用序列图</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Binder通信过程中的结点管理</h2>
<div class="outline-text-2" id="text-2">
<p>
BpBinder类代表一个远程Binder对象（继承自BpRefBase）的通信功能部分。
它提供了linkToDeath方法，供其他对象监听自己所关联的本地结点的死亡
通知，本质上是通过调用IPCThreadState类的requestDeathNotification接
口。unlinkToDeath方法则是取消接收Binder结点的死亡通知。而
sendObituary则是向监听者发送结点的死亡通知。这两个接口都会通过
IPCThreadState类的clearDeathNotification将消息处理发送到Binder驱动
去处理。
</p>

<p>
一般BpBinder对象是包含于从BpRefBase继承过来的类中，也即BpINTERFACE
类的一个私有成员，代表IPC通信的一方与另一方进行通信。在Binder驱动，
要支持死亡通知机制，是通过 <code>binder_ref</code> 来实现的。 <code>binder_ref</code> 有一个成员
是指向 <code>struct binder_ref_death</code> 结构的指针。它的结构定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">struct binder_ref_death {
        struct binder_work work;
        binder_uintptr_t cookie;
};
</pre>
</div>

<p>
其中，work是指提交给当前线程或进程处理的工作类型，一般为如下三种：
</p>
<div class="org-src-container">

<pre class="src src-c">BINDER_WORK_DEAD_BINDER, //dead binder
BINDER_WORK_DEAD_BINDER_AND_CLEAR, //clear dead binder
BINDER_WORK_CLEAR_DEATH_NOTIFICATION, //clear death notification
</pre>
</div>

<p>
cookie则一般保存的是BpBinder对象的内存地址，主要用于标识当前的通信
会话。
</p>

<p>
<b>linkToDeath(…)接口代码分析</b>  
</p>

<p>
该接口的原型如下：
</p>
<div class="org-src-container">

<pre class="src src-c++">virtual status_t    linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient,
                                    void* cookie = NULL,
                                    uint32_t flags = 0);
</pre>
</div>

<p>
使用示例如下，SurfaceFlinger将监听window manager进程的死亡消息：
</p>
<div class="org-src-container">

<pre class="src src-c++">void SurfaceFlinger::bootFinished()
｛
        。。。
    // wait patiently for the window manager death
    const String16 name("window");
    sp&lt;IBinder&gt; window(defaultServiceManager()-&gt;getService(name));
    if (window != 0) {
        window-&gt;linkToDeath(static_cast&lt;IBinder::DeathRecipient*&gt;(this));
    }
        。。。
｝
</pre>
</div>

<p>
下面看下linkToDeath方法调用的流程：
</p>

<p>
[ -&gt; BpBinder: linkToDeath
BpBinder -&gt; IPCThreadState: requestDeathNotification
IPCThreadState -&gt; Binder Driver: BC_REQUEST_DEATH_NOTIFICATION
</p>


<p>
下面看下处理 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 的代码逻辑：
</p>

<p>
由于requestDeathNotification方法传入的两个参数一个是远程Binder结点
的句柄以及对象本身的内存地址（BpBinder对象），所以驱动依次拿到这两
个参数：
</p>

<div class="org-src-container">

<pre class="src src-c">int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
                        binder_uintptr_t binder_buffer, size_t size,
                        binder_size_t *consumed)
{
  …
 case BC_REQUEST_DEATH_NOTIFICATION:
 case BC_CLEAR_DEATH_NOTIFICATION: {
   uint32_t target;
   binder_uintptr_t cookie;
   struct binder_ref *ref;
   struct binder_ref_death *death;

   if (get_user(target, (uint32_t __user *)ptr))
     return -EFAULT;
   ptr += sizeof(uint32_t);
   if (get_user(cookie, (binder_uintptr_t __user *)ptr))
     return -EFAULT;
   ptr += sizeof(binder_uintptr_t);
   //其中通过第一个参数在当前进程找到对应的binder_ref实例，
     ref = binder_get_ref(proc, target);

     //下面是处理BC_REQUEST_DEATH_NOTIFICATION的代码：

     if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
       如果ref-&gt;death不为空，则说明之前已经调用过requestDeathNotification，直接忽略这次调用。
         if (ref-&gt;death) {
           binder_user_error("%d:%d BC_REQUEST_DEATH_NOTIFICATION death notification already set\n",
                             proc-&gt;pid, thread-&gt;pid);
           break;
         }
       //否则，则创建一个binder_ref_death实例，并绑定给上述的binder_ref实例。
         death = kzalloc(sizeof(*death), GFP_KERNEL);
       if (death == NULL) {
         thread-&gt;return_error = BR_ERROR;
         binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
                      "%d:%d BC_REQUEST_DEATH_NOTIFICATION failed\n",
                      proc-&gt;pid, thread-&gt;pid);
         break;
       }
       binder_stats_created(BINDER_STAT_DEATH);
       INIT_LIST_HEAD(&amp;death-&gt;work.entry);
       death-&gt;cookie = cookie;
       ref-&gt;death = death;
       //如果远程Binder结点所在的进程已经退出，则说明远程Binder结点已经死亡，应该发送死亡通知，是通过与之关联的binder_ref的死亡列表发送通知的。
         if (ref-&gt;node-&gt;proc == NULL) {
           ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;
           // 如果当前线程没有退出，就发送到线程的事件处理链表中，否则发送到进程的事件处理链表中。
             if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
               list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);
             } else {
               list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);
               wake_up_interruptible(&amp;proc-&gt;wait);
             }
         }
     }
     //这里说明下，当ref-&gt;death-&gt;work.entry链表为空，说明binder_ref关联的远程Binder结点还处于活跃状态，无需发送死亡通知。
</pre>
</div>

<p>
<b>unlinkToDeath(…)</b> 
</p>


<p>
[ -&gt; BpBinder: unlinkToDeath
BpBinder -&gt; IPCThreadState: clearDeathNotification
IPCThreadState -&gt; Binder Driver: BC_CLEAR_DEATH_NOTIFICATION
</p>


<p>
下面来看处理 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 的逻辑。
</p>

<p>
发出这个命令的情形有两种：
</p>
<ol class="org-ol">
<li>结点没有死亡，此时提交的工作类型为
<code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> ，只是取消监听结点的死亡通知，
不影响其他对象对该结点的监听。
</li>
<li>结点已经死亡，此时提交的工作类型为
<code>BINDER_WORK_DEAD_BINDER_AND_CLEAR</code> ，
这时是要清除。

<div class="org-src-container">

<pre class="src src-c">int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
                        binder_uintptr_t binder_buffer, size_t size,
                        binder_size_t *consumed)
{
  …
 case BC_REQUEST_DEATH_NOTIFICATION:
 case BC_CLEAR_DEATH_NOTIFICATION: {
   …
     if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
       …
         } else {
       if (ref-&gt;death == NULL) {
         binder_user_error("%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification not active\n",
                           proc-&gt;pid, thread-&gt;pid);
         break;
       }
       death = ref-&gt;death;
       //通过cookie来标识当前通信会话
         if (death-&gt;cookie != cookie) {
           binder_user_error("%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification cookie mismatch %016llx != %016llx\n",
                             proc-&gt;pid, thread-&gt;pid,
                             (u64)death-&gt;cookie, (u64)cookie);
           break;
         }
       ref-&gt;death = NULL;
       // ''如果death-&gt;work.entry为空，说明被监听的Binder结点还处于活跃状态，这时只是取消对该结点的死亡监听
         if (list_empty(&amp;death-&gt;work.entry)) {
           death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
           if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
             list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
           } else {
             list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
             wake_up_interruptible(&amp;proc-&gt;wait);
           }
         } else {
           //  否则，该结点已经死亡，将当前工作类型修改为BINDER_WORK_DEAD_BINDER_AND_CLEAR
             BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);
           death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;
         }
     }

   …
     }
</pre>
</div>

<p>
如下是处于当前线程或进程上的 <code>binder_work</code> 的处理过程：
</p>
<div class="org-src-container">

<pre class="src src-c">static int binder_thread_read(struct binder_proc *proc,
                              struct binder_thread *thread,
                              binder_uintptr_t binder_buffer, size_t size,
                              binder_size_t *consumed, int non_block)
{
  …
    while (1) {
      …
        //从当前线程或进程中取出提交上来的工作类型
        if (!list_empty(&amp;thread-&gt;todo))
          w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
          w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);
        else {
          …
            }
      …
        switch (w-&gt;type) {
          …
        case BINDER_WORK_DEAD_BINDER:
        case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
        case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
          struct binder_ref_death *death;
          uint32_t cmd;

          death = container_of(w, struct binder_ref_death, work);
          if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)
            //被监听的结点没有死亡，通知用户空间减少对该结点的弱引用计数
              cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;
          else
            //被监听的结点已经死亡，发送BR_DEAD_BINDER通知用户空间处理
              cmd = BR_DEAD_BINDER;
          if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
          ptr += sizeof(uint32_t);
          if (put_user(death-&gt;cookie,
                       (binder_uintptr_t __user *)ptr))
            return -EFAULT;
          ptr += sizeof(binder_uintptr_t);
          binder_stat_br(proc, thread, cmd);
          binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,
                       "%d:%d %s %016llx\n",
                       proc-&gt;pid, thread-&gt;pid,
                       cmd == BR_DEAD_BINDER ?
                       "BR_DEAD_BINDER" :
                       "BR_CLEAR_DEATH_NOTIFICATION_DONE",
                       (u64)death-&gt;cookie);

          if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {
            //这种情况是要删除death实例
              list_del(&amp;w-&gt;entry);
            kfree(death);
            binder_stats_deleted(BINDER_STAT_DEATH);
          } else
            // 将death实例的清理工作，提交到进程中延后处理（在收到BC_DEAD_BINDER_DONE时处理）
              list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);
          //由于BR_DEAD_BINDER还要触发用户空间向Binder驱动发送后续命令BC_CLEAR_DEATH_NOTIFICATION， BC_DEAD_BINDER_DONE， 所以应当退出当前循环，以便当前线程能够处理上述命令。
            if (cmd == BR_DEAD_BINDER)
              goto done; /* DEAD_BINDER notifications can cause transactions */
        } break;
        }
      …
        }
</pre>
</div>

<p>
如果在requestDeathNotification的时候结点已经退出，或Binder通信
结束，Binder结点被释放，调用了 <code>binder_node_release</code> ，驱动会返回
<code>BR_DEAD_BINDER</code> 命令，通知上层处理。
</p>
<div class="org-src-container">

<pre class="src src-c++">status_t IPCThreadState::executeCommand(int32_t cmd)
｛
        。。。
    case BR_DEAD_BINDER:
        {
            BpBinder *proxy = (BpBinder*)mIn.readInt32();
            proxy-&gt;sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writeInt32((int32_t)proxy);
        } break;
        。。。
｝
</pre>
</div>

<p>
首先，代表远程结点通信的BpBinder会调用sendObituary命令，清除对
它的死亡通知列表（会向驱动发送 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 命
令），并调用监听者的回调函数通知监听者。之后，会向驱动发送
<code>BC_DEAD_BINDER_DONE</code> ，通知驱动善后处理。
</p>

<p>
下面看下 <code>BC_DEAD_BINDER_DONE</code> 的处理过程：
</p>
<div class="org-src-container">

<pre class="src src-c">case BC_DEAD_BINDER_DONE: {
  struct binder_work *w;
  binder_uintptr_t cookie;
  struct binder_ref_death *death = NULL;
  if (get_user(cookie, (binder_uintptr_t __user *)ptr))
    return -EFAULT;

  ptr += sizeof(void *);
  //从当前进程的延迟处理列表中，取出要处理的工作类型
    list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) {
    struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work);
    //通过cookie来新知识对应的binder_ref_death实例
      if (tmp_death-&gt;cookie == cookie) {
        death = tmp_death;
        break;
      }
  }
  binder_debug(BINDER_DEBUG_DEAD_BINDER,
               "%d:%d BC_DEAD_BINDER_DONE %016llx found %p\n",
               proc-&gt;pid, thread-&gt;pid, (u64)cookie, death);
  //如果相关信息无法找到，则直接退出，无需后续处理
    if (death == NULL) {
      binder_user_error("%d:%d BC_DEAD_BINDER_DONE %016llx not found\n",
                        proc-&gt;pid, thread-&gt;pid, (u64)cookie);
      break;
    }

  list_del_init(&amp;death-&gt;work.entry);
  //结点已经死亡，需要清理消息通知相关信息
    if (death-&gt;work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {
      death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
      if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
      } else {
        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
        wake_up_interruptible(&amp;proc-&gt;wait);
      }
    }
} break;
</pre>
</div>

<p>
<b>IPC通信过程示例</b>
</p>

<pre class="example">
BC_DEAD_BINDER(binder_node_release或BC_REQUEST_DEATH_NOTIFICATION)
-&gt;BR_DEAD_BINDER(binder_thread_read)
-&gt; BC_CLEAR_DEATH_NOTIFICATION（如果结点已经死亡，则工作类型修改为BINDER_WORK_DEAD_BINDER_AND_CLEAR）
-&gt; BC_DEAD_BINDER_DONE（将工作类型修改为BINDER_WORK_CLEAR_DEATH_NOTIFICATION，提交到当前线程或进程进一步处理）
-&gt; BR_CLEAR_DEATH_NOTIFICATION_DONE
</pre>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Looper类代码分析</h2>
<div class="outline-text-2" id="text-3">
<p>
　　本文将分析一下Looper类的实现及其应用，代码位于
frameworks/native/lib/utils/Looper.cpp。主要分为如下几个部分：
</p>
<ol class="org-ol">
<li>epoll系统调用接口简介
</li>
<li>Looper类代码分析
</li>
<li>Looper类应用实例分析
</li>
</ol>

<p>
<b>一、epoll系统调用接口简介</b>
</p>

<p>
Looper事件机制实际上是依赖系统调用epoll实现的。它是一种I/O复用模型，
即可以同时监控多个I/O事件。对于Looper来说，所谓的I/O事件就是所监控
的文件描述符上没有有数据到达。epoll的主要接口如下所示 ：
</p>
<ol class="org-ol">
<li><code>epoll_create()</code>
创建一个epoll实例，返回引用该实例的文件描述符。
原型如下所示 ：
<pre class="example">
int epoll_create(int size );
</pre>
<p>
参数size指定了我们想通过epoll实例监控文件描述符的数量。
</p>
</li>
<li><code>epoll_ctl()</code>
　　操作与该epoll实例相关联的兴趣列表：添加一个文件描述符到兴趣
列表中，从兴趣列表中删除一个现存的文件描述符以及修改事件掩码以决
定要监控文件描述符上发生的哪个事件。
原型如下所示：
<pre class="example">
int epoll_ctl(int epfd , int op , int fd , struct epoll_event * ev );
</pre>

<p>
其中参数op可以取如下一些值：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">EPOLL_CTL_ADD</th>
<th scope="col" class="left">将fd加入了监控列表</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">EPOLL_CTL_MOD</td>
<td class="left">修改当前监控的fd相关信息</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">EPOLL_CTL_DEL</td>
<td class="left">将fd从监控列表中删除</td>
</tr>
</tbody>
</table>
</li>
<li><code>epoll_wait()</code>
从I/O Ready列表中返回与epoll实例相关联的项，即返回有事件发生的文
件描述符的数量。
原型如下所示：
<pre class="example">
int epoll_wait(int epfd , struct epoll_event * evlist , int maxevents , int timeout );
</pre>
<p>
其中timeout值为-1时，表示无限等待直到有事件发生。为0时，执行一个
非阻塞检查后立即返回。大于0时，表示一个超时时间值。
</p>

<p>
另外， <code>struct epoll_event</code> 结构定义如下所示 ：
</p>
<div class="org-src-container">

<pre class="src src-c">struct epoll_event {
    uint32_t events;  /* epoll events (bit mask) */
    epoll_data_t data; /* User data */
};
</pre>
</div>

<p>
主要的事件掩码有：
EPOLLIN：代表有数据可读
EPOLLOUT：代表有数据可写
</p>

<p>
<code>epoll_data_t</code> 的数据结构定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">typedef union epoll_data {
    void *ptr;  /* Pointer to user-defined data */
    int fd;  /*File descriptor */
    uint32_t u32; /* 32-bit integer */
    uint64_t u64; /* 64-bit integer */
} epoll_data_t;
</pre>
</div>

<p>
使用实例:
</p>
<div class="org-src-container">

<pre class="src src-c">int epfd;
struct epoll_event ev;
epfd = epoll_create(5);
if (epfd == -1)
    errExit("epoll_create");
ev.data.fd = fd;
ev.events = EPOLLIN;
if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)
    errExit("epoll_ctl");
...
epoll_wait(...);
</pre>
</div>
</li>
</ol>

<p>
<b>二、Looper类代码分析</b>
</p>

<p>
Looper类定义了一种事件接口，这里所谓的事件就是文件描述符上的I/O数据
是否可读或可写。它提供了一系列接口来支持事件通知和响应，通过轮询，
利用epoll系统调用，可以侦测到发生在文件描述符上的I/O事件。
</p>

<p>
在分析Looper类之前，我们先来看两个与之相关的接口：
</p>
<ol class="org-ol">
<li>Looper消息处理接口。
<div class="org-src-container">

<pre class="src src-c">class MessageHandler : public virtual RefBase {
protected:
    virtual ~MessageHandler() { }

public:
    /**
     * Handles a message.
     */
    virtual void handleMessage(const Message&amp; message) = 0;
};
</pre>
</div>

<p>
与之相关的Looper类的几个成员函数定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">/**
 * Enqueues a message to be processed by the specified handler.
 */
void sendMessage(const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message);

/**
 * Enqueues a message to be processed by the specified handler after all pending messages
 * after the specified delay.
 */
void sendMessageDelayed(nsecs_t uptimeDelay, const sp&lt;MessageHandler&gt;&amp; handler,
        const Message&amp; message);

/**
 * Enqueues a message to be processed by the specified handler after all pending messages
 * at the specified time.
 */
void sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler,
        const Message&amp; message);

/**
 * Removes all messages for the specified handler from the queue.
 */
void removeMessages(const sp&lt;MessageHandler&gt;&amp; handler);

/**
 * Removes all messages of a particular type for the specified handler from the queue.
 */
void removeMessages(const sp&lt;MessageHandler&gt;&amp; handler, int what);
</pre>
</div>

<p>
　　从上述成员函数的定义可以看到，Looper对MessageHandler都拥有强
引用，所以需要通过显式调用remoeveMessage将其删掉。
</p>

<p>
　　此外，也定义了一个WeakMessageHandler类，它通过一个弱引用来引
用一个MessageHandler对象，在需要的时候强化为强引用。
</p>
</li>

<li>Looper回调函数接口。
回调函数类定义如下：
<div class="org-src-container">

<pre class="src src-c">/**
 * A looper callback.
 */
class LooperCallback : public virtual RefBase {
protected:
    virtual ~LooperCallback() { }

public:
    /**
     * Handles a poll event for the given file descriptor.
     * It is given the file descriptor it is associated with,
     * a bitmask of the poll events that were triggered (typically ALOOPER_EVENT_INPUT),
     * and the data pointer that was originally supplied.
     *
     * Implementations should return 1 to continue receiving callbacks, or 0
     * to have this file descriptor and callback unregistered from the looper.
     */
    virtual int handleEvent(int fd, int events, void* data) = 0;
};
</pre>
</div>

<p>
同样地，也定义了一个辅助类SimpleLooperCallback，它支持接受一个回
调函数指针。
</p>
<pre class="example">
typedef int (*ALooper_callbackFunc)(int fd, int events, void* data);
</pre>

<p>
与之相关的Looper类的成员函数如下所示 ：
</p>
<pre class="example">
int addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data);
int addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data);
</pre>

<p>
　　这两个成员函数的主要作用是：将要监控的fd加入到Looper的事件监
控列表中。这里，可以指定回调函数。当有事件发生时，Looper实例会自
动调用回调函数。如果回调函数为空，则由调用者处理发生的事件。
</p>

<p>
　　下面将分析Looper类的实现。先分析下成员变量的意义：
</p>

<div class="org-src-container">

<pre class="src src-c++">const bool mAllowNonCallbacks; // immutable

int mWakeReadPipeFd;  // immutable
int mWakeWritePipeFd; // immutable
Mutex mLock;

Vector&lt;MessageEnvelope&gt; mMessageEnvelopes; // guarded by mLock
bool mSendingMessage; // guarded by mLock

int mEpollFd; // immutable

// Locked list of file descriptor monitoring requests.
KeyedVector&lt;int, Request&gt; mRequests;  // guarded by mLock

// This state is only used privately by pollOnce and does not require a lock since
// it runs on a single thread.
Vector&lt;Response&gt; mResponses;
size_t mResponseIndex;
nsecs_t mNextMessageUptime; // set to LLONG_MAX when none
</pre>
</div>

<p>
　　它们的表示的意义如下所示:
　　mAllowNonCallbacks: 表示是否允许将文件描述符加入监控对象时，
指定回调函数为空。
</p>

<p>
　　mWakeReadPipeFd：Looper类默认构造的双向管道的只读端。
</p>

<p>
　　mWakeWritePipeFd：Looper类默认构造的双向管道的只写端。
</p>

<p>
mLock：互斥访问保护锁，主要Looper类的一些成员变量的并发访问。
</p>

<p>
　　mMessageEnvelopes：Looper实例包含的“消息信封”集合。消息信封
主要包含如下属性：时间戳，消息处理函数指针以及消息本身。
</p>

<p>
　　mSendingMessage：当前Looper实例是否正在发送消息。
</p>

<p>
　　mEpollFd：epoll实例对应的描述符。
</p>

<p>
mRequests：当前Looper实例中的文件描述符监控请求。对就的数据结构
struct Request定义如下：
</p>

<div class="org-src-container">

<pre class="src src-c">struct Request {
  int fd;
  int ident;
  sp&lt;LooperCallback&gt; callback;
  void* data;
};
</pre>
</div>

<p>
其中，fd表示监控的文件描述符，ident表示表示监控的事件标识。
callback是事件发生时，对应的回调函数。data为传递给回调函数的自定
义数据。
</p>

<p>
mResponses：当前的响应集合。数据结构Response的定义如下：
</p>

<div class="org-src-container">

<pre class="src src-c">struct Response {
  int events;
  Request request;
};
</pre>
</div>

<p>
mResponseIndex：响应索引号。
</p>

<p>
mNextMessageUptime：下一个消息处理的时间。
</p>

<p>
　　接下来，看构造函数声明：
</p>
<pre class="example">
Looper(bool allowNonCallbacks);
</pre>

<p>
　　参数allowNonCallbacks表示是否允许将文件描述符加入监控对象时，
指定回调函数为空。
</p>

<p>
　　其实现如下所示：
　　首先，它创建了一个双向管道，一端读，一端写。并将其设置为非阻
塞模式。然后创建epoll实例，将只读端管道文件描述符中入到epoll的监
控列表中，这样保护epoll实例中至少包含有一个文件描述符在其事件监
控列表中。详细代码如下所示 ：
</p>

<div class="org-src-container">

<pre class="src src-c++">Looper::Looper(bool allowNonCallbacks) :
  mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
  mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
  int wakeFds[2];
  int result = pipe(wakeFds);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not create wake pipe.  errno=%d", errno);

  mWakeReadPipeFd = wakeFds[0];
  mWakeWritePipeFd = wakeFds[1];

  result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake read pipe non-blocking.  errno=%d",
                      errno);

  result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake write pipe non-blocking.  errno=%d",
                      errno);

  // Allocate the epoll instance and register the wake pipe.
  mEpollFd = epoll_create(EPOLL_SIZE_HINT);
  LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, "Could not create epoll instance.  errno=%d", errno);

  struct epoll_event eventItem;
  memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
  eventItem.events = EPOLLIN;
  eventItem.data.fd = mWakeReadPipeFd;
  result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake read pipe to epoll instance.  errno=%d",
                      errno);
}
</pre>
</div>

<p>
　　再来看与线程相关的几个类的静态函数：
</p>
<pre class="example">
static sp&lt;Looper&gt; prepare(int opts);
</pre>
<p>
　　将一个Looper实例与调用者所在的线程关联。Opts的值为： 
　　 <code>ALOOPER_PREPARE_ALLOW_NON_CALLBACKS</code> 或0，它返回该Looper实
例。
</p>

<pre class="example">
static void setForThread(const sp&lt;Looper&gt;&amp; looper);
</pre>
<p>
设置looper对象与当前线程关联。如果当前looper对象已经存在，则替换
掉。如果looper为NULL，则删除当前关联的looper对象。
</p>

<pre class="example">
static sp&lt;Looper&gt; getForThread();
</pre>
<p>
　　返回当前线程关联的Looper实例。
</p>

<p>
接下来看下两个比较重要的成员函数：
</p>
<pre class="example">
int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data)
</pre>
<p>
该函数主要是将fd加入到Looper的事件监控列表中。如果
allowNonCallbacks为false，则必须指定回调函数，且此时ident值为
<code>ALOOPER_POLL_CALLBACK(-2)</code> ，忽略传入的indent的值，而回调函数为空
时，传入的ident值不能小于0 。实际上会通过系统调用epoll_ctl将fd加
入到epoll实例的事件监控列表中。同时，也记录下此次的监控信息，封
装成一个Request实例，加入到成员变量mRequests当中。如果fd已经存在，
则替换掉旧的Request对象。
</p>

<pre class="example">
void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) 
</pre>
<p>
该函数主要作用就是发送一个Message对象，实现就是注册一个
MessageEnvelop（消息信封）实例，加入到成员变量mMessageEnvelopes，
它是按消息触发的时间排序的。
</p>

<p>
最后，我们来看下它的核心成员函数pollOnce，基本流程图如下所示 ：
<img src="../images/2016/2016073001.jpg" alt="2016073001.jpg" />
</p>

<p>
　　下面来分析上述过程：
</p>
<ol class="org-ol">
<li>Handle response
<div class="org-src-container">

<pre class="src src-c++">for (;;) {
  while (mResponseIndex &lt; mResponses.size()) {
    const Response&amp; response = mResponses.itemAt(mResponseIndex++);
    int ident = response.request.ident;
    if (ident &gt;= 0) {
      int fd = response.request.fd;
      int events = response.events;
      void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE
      ALOGD("%p ~ pollOnce - returning signalled identifier %d: "
            "fd=%d, events=0x%x, data=%p",
            this, ident, fd, events, data);
#endif
      if (outFd != NULL) *outFd = fd;
      if (outEvents != NULL) *outEvents = events;
      if (outData != NULL) *outData = data;
      return ident;
    }
  }
</pre>
</div>

<p>
　　针对回调函数为空的情况，ident值必为一个大于等于0的值（注：
有回调函数时，indent的值为-2）。所以上述这段代码只会发生在回
调函数为空的情况，此时将返回发生事件的描述符，发生的事件以及
返回的数据，供调用者进一步处理。
</p>
</li>

<li>Handle result.
<div class="org-src-container">

<pre class="src src-c++">for(;;) {
...
       if (result != 0) {
#if DEBUG_POLL_AND_WAKE
            ALOGD("%p ~ pollOnce - returning result %d", this, result);
#endif
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }
...
}
</pre>
</div>

<p>
这段代码实际上是根据pollInner的结果进行处理，实际上是针对设置
了回调函数的情况，因为设置了回调函数，所以已经对发生的事件做
了处理了，所以，不需要将发生事件的相关信息再返回给调用者了。
</p>
</li>

<li>pollInner
<div class="org-src-container">

<pre class="src src-c++">for(;;) {
...
 result = pollInner(timeoutMillis);
}
</pre>
</div>

<ol class="org-ol">
<li>Ajust the time out.
<div class="org-src-container">

<pre class="src src-c++">int Looper::pollInner(int timeoutMillis) {
    ...
    // Adjust the timeout based on when the next message is due.
    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
        if (messageTimeoutMillis &gt;= 0
                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
            timeoutMillis = messageTimeoutMillis;
        }
　　...
　　}
　　...
}
</pre>
</div>
<p>
　　为什么要调整超时时间值，原因很简单：因为对于消息来说，
可能有多个消息，且每个消息触发的时间点不同，一次事件的触发
导致epoll_wait返回并不能处理完所有的消息，所有会多次调用
epoll_wait函数，由于超时值是第一次调用时指定的，所以再次调
用时，需要重新计算，要去掉已经消耗的时间。代码中now记录当
前的时间值，toMillisecondTimeoutDelya(&#x2026;)计算这本次循环的
超时值。上述的判断条件指明了什么情况下需要做些调整：
</p>
<ul class="org-ul">
<li>当前的消息触发时间不早于当前时间。（即消息没有过时）
</li>

<li>上轮 <code>epoll_wait</code> 指定的超时值为-1或一个较大的数值（&gt;
messageTimeoutMillis）。
</li>
</ul>
</li>

<li>wait for event(epoll wait)
<div class="org-src-container">

<pre class="src src-c++">               ...
               struct epoll_event eventItems[EPOLL_MAX_EVENTS];
           　　int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
           　　...
</pre>
</div>

<p>
主要通过 <code>epoll_wait</code> 系统调用检测事件的发生。
</p>
</li>

<li>handle the event

<div class="org-src-container">

<pre class="src src-c++">...
  for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on wake read pipe.", epollEvents);
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                pushResponse(events, mRequests.valueAt(requestIndex));
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on fd %d that is "
                        "no longer registered.", epollEvents, fd);
            }
        }
　　}
　　...
</pre>
</div>

<p>
　　对于Looper对象内置的管道，处理EPOLLIN事件，而对于其他
监听的文件描述符，则分别记录下EPOLLIN， EPOLLOUT，
EPOLLERR， EPOLLHUP并打包成Response对象加入到mResponses中
进行处理。
</p>
</li>

<li>invoke pending message callbacks
<div class="org-src-container">

<pre class="src src-c++">  // Invoke pending message callbacks.
    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            // Remove the envelope from the list.
            // We keep a strong reference to the handler until the call to handleMessage
            // finishes.  Then we drop it so that the handler can be deleted *before*
            // we reacquire our lock.
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();

#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                ALOGD("%p ~ pollOnce - sending message: handler=%p, what=%d",
                        this, handler.get(), message.what);
#endif
                handler-&gt;handleMessage(message);
            } // release handler

            mLock.lock();
            mSendingMessage = false;
            result = ALOOPER_POLL_CALLBACK;
        } else {
            // The last message left at the head of the queue determines the next wakeup time.
            mNextMessageUptime = messageEnvelope.uptime;
            break;
        }
    }
</pre>
</div>

<p>
messageEnvelope.uptime代表该消息被处理的时机，先处理掉已经
过时的消息，即messageEnvelope.uptime &lt;= now， 如果还有未过
时的消息，则记录下它应该被处理的时间：mNextMessageUptime =
messageEnvelope.uptime；也即下次被触发的时间。这个值也作为
3.1中调整epoll_wait超时时间的值。
</p>
</li>

<li>invoke all response callback
　　对于回调函数不为空的情形，在事件触发后，就会自动执行调
用者提供的回调函数，如下面代码所示：

<div class="org-src-container">

<pre class="src src-c++"> // Invoke all response callbacks.
    for (size_t i = 0; i &lt; mResponses.size(); i++) {
        Response&amp; response = mResponses.editItemAt(i);
        if (response.request.ident == ALOOPER_POLL_CALLBACK) {
            int fd = response.request.fd;
            int events = response.events;
            void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
            ALOGD("%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p",
                    this, response.request.callback.get(), fd, events, data);
#endif
            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);
            if (callbackResult == 0) {
                removeFd(fd);
            }
            // Clear the callback reference in the response structure promptly because we
            // will not clear the response vector itself until the next poll.
            response.request.callback.clear();
            result = ALOOPER_POLL_CALLBACK;
        }
</pre>
</div>
</li>
</ol>
</li>
</ol>
</li>
</ol>

<p>
<b>三、Looper类应用实例分析</b>
</p>

<p>
　　下面来看下Looper类的API的使用。
</p>
<ol class="org-ol">
<li>Looper对象初始化
<div class="org-src-container">

<pre class="src src-c++">sp&lt;Looper&gt; mLooper = new Looper(true);
...
mLooper.clear();
</pre>
</div>
</li>
<li>pollOnece函数的使用
<div class="org-src-container">

<pre class="src src-c++">StopWatch stopWatch("pollOnce");
int result = mLooper-&gt;pollOnce(1000);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());
</pre>
</div>
<p>
返回值为 result = <code>ALOOPER_POLL_WAKE</code>
</p>
</li>
<li>设置CallBack
定义回调函数：
<div class="org-src-container">

<pre class="src src-c++">class CallbackHandler {
public:
    void setCallback(const sp&lt;Looper&gt;&amp; looper, int fd, int events) {
        looper-&gt;addFd(fd, 0, events, staticHandler, this);
    }

protected:
    virtual ~CallbackHandler() { }

    virtual int handler(int fd, int events) = 0;

private:
    static int staticHandler(int fd, int events, void* data) {
        return static_cast&lt;CallbackHandler*&gt;(data)-&gt;handler(fd, events);
    }
};

class StubCallbackHandler : public CallbackHandler {
public:
    int nextResult;
    int callbackCount;

    int fd;
    int events;

    StubCallbackHandler(int nextResult) : nextResult(nextResult),
            callbackCount(0), fd(-1), events(-1) {
    }

protected:
    virtual int handler(int fd, int events) {
        callbackCount += 1;
        this-&gt;fd = fd;
        this-&gt;events = events;
        return nextResult;
    }
};
</pre>
</div>

<p>
使用实例：
</p>
<div class="org-src-container">

<pre class="src src-c++">Pipe pipe;
StubCallbackHandler handler(true);

pipe.writeSignal();
handler.setCallback(mLooper, pipe.receiveFd, ALOOPER_EVENT_INPUT);

StopWatch stopWatch("pollOnce");
int result = mLooper-&gt;pollOnce(100);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());
　　...
</pre>
</div>

<p>
result的值为 <code>ALOOPER_POLL_CALLBACK</code> 。
</p>
</li>
<li>Callback为空的情形
　　若设置Callback为空，此时事件的标识符ident必须是一个大于或等
于0的值。如下代码所示：
<div class="org-src-container">

<pre class="src src-c++">const int expectedIdent = 5;
void* expectedData = this;

Pipe pipe;

pipe.writeSignal();
mLooper-&gt;addFd(pipe.receiveFd, expectedIdent, ALOOPER_EVENT_INPUT, NULL, expectedData);

StopWatch stopWatch("pollOnce");
int fd;
int events;
void* data;
int result = mLooper-&gt;pollOnce(100, &amp;fd, &amp;events, &amp;data);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());
</pre>
</div>

<p>
此时返回值result等于ident的值。
</p>
</li>
<li>通过Looper发送消息
　　此种情况下一般不需要调用addFd，通过Looper默认创建的管道来监
听事件就行了。它的使用示例如下：
　　首先要定义一个MessageHandler的派生类，用于处理消息：
<div class="org-src-container">

<pre class="src src-c++">class StubMessageHandler : public MessageHandler {
public:
    Vector&lt;Message&gt; messages;

    virtual void handleMessage(const Message&amp; message) {
        messages.push(message);
    }
};
</pre>
</div>

<p>
接着就可以通过SendMessage相关的函数发送消息到Looper实例上：
</p>

<div class="org-src-container">

<pre class="src src-c++">nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
sp&lt;StubMessageHandler&gt; handler = new StubMessageHandler();
mLooper-&gt;sendMessageAtTime(now + ms2ns(100), handler, Message(MSG_TEST1));

StopWatch stopWatch("pollOnce");
int result = mLooper-&gt;pollOnce(1000);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());

...

result = mLooper-&gt;pollOnce(1000);
elapsedMillis = ns2ms(stopWatch.elapsedTime());

...
result = mLooper-&gt;pollOnce(100);
elapsedMillis = ns2ms(stopWatch.elapsedTime());
</pre>
</div>

<pre class="example">
第一次
elapsedMillis = 0;
result = ALOOPER_POLL_WAKE
Message size = 0;
第二次
elapsedMillis = 100
result = ALOOPER_POLL_CALLBACK
Message size = 1
第三次
result = ALOOPER_POLL_TIMEOUT
没有消息需要处理。
</pre>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Android Region代码分析</h2>
<div class="outline-text-2" id="text-4">
<p>
<b>一、Region的定义和合法性检查</b>
</p>

<p>
　　在Android系统中，定义了Region的概念，它代表屏幕上的一个区域，它
是由一个或多个Rect组成的，代码位于
frameworks/native/libs/ui/Region.cpp。而Rect则代表屏幕上的一个方形
区域，这个区域可能是不可见的，部分可见或者完全不可见的。从代码实现
的角度来看Region的实现，它拥有一个私有的数据成员变量：mStorage，它
的类型为Vector&lt;Rect&gt;：
</p>
<ol class="org-ol">
<li>mStorage是一个有序数组，数组元素类型为Rect，除了包含构成Region区
域的Rect外，还额外地包含一个元素，它就是这块区域的边界。
</li>
<li>如果Region只是一个简单的方形区域，则mStorage只包含这个Rect类型的
元素。
　　从上述两点可知，mStorge的大小永远不可能为2，要想知道某个区域
的边界大小，只需返回mStorage的最后一个元素。
</li>
<li>Rect与Region的关系是is-a关系，反之则不成立。

<div class="org-src-container">

<pre class="src src-c++">inline  bool        isEmpty() const     { return getBounds().isEmpty(); }
inline  bool        isRect() const      { return mStorage.size() == 1; }

inline  Rect        getBounds() const   { return mStorage[mStorage.size() - 1]; }
inline  Rect        bounds() const      { return getBounds(); }
</pre>
</div>
</li>
</ol>


<p>
　　接下来研究的话题是Region的合法性。由于Region本身是由一系列Rect
组成的，所以，首先，构成的Rect本身必须是合法的。其次，构成的Rect必
须以Y方向和X方向排序，Y方向优先排序。这里引入另一个概念Span，它也是
一个区域的概念，也是由一个或多个Rect组成，可以认为它是一种特殊的
Region， 其本身也是构成Region的一部分，事实上，一个Region可以看成是
由许多Span构成的。不过这些构成Span的Rect必须在Y方向上，top和bottom
值与其他的Rect相同，即Y方向上不能重叠，在X上方向，left与right之间的
覆盖的区域不能与其他的Rect之间有重叠。基于上述的描述，要检查一个
Region是否合法，就要对上述的一些要求做检查，我们可以看Region的
validate()函数，它实际上就是这样做的：
</p>

<ol class="org-ol">
<li>首先检查构成Region的Rect本身的合法性。
<div class="org-src-container">

<pre class="src src-c++">...
if (cur-&gt;isValid() == false) {
  ALOGE_IF(!silent, "%s: region contains an invalid Rect", name);
  result = false;
 }
if (cur-&gt;right &gt; region_operator&lt;Rect&gt;::max_value) {
  ALOGE_IF(!silent, "%s: rect-&gt;right &gt; max_value", name);
  result = false;
 }
if (cur-&gt;bottom &gt; region_operator&lt;Rect&gt;::max_value) {
  ALOGE_IF(!silent, "%s: rect-&gt;right &gt; max_value", name);
  result = false;
 }
...
</pre>
</div>
</li>
<li>接下来，检查这些Rect是否是有序的。

<div class="org-src-container">

<pre class="src src-c++">if ((*prev &lt; *cur) == false) {
  ALOGE_IF(!silent, "%s: region's Rects not sorted", name);
  result = false;
 }
</pre>
</div>
</li>
<li>然后就是检查Span的合法性
<div class="org-src-container">

<pre class="src src-c++">if (cur-&gt;top == prev-&gt;top) {
  if (cur-&gt;bottom != prev-&gt;bottom) {
    ALOGE_IF(!silent, "%s: invalid span %p", name, cur);
    result = false;
  } else if (cur-&gt;left &lt; prev-&gt;right) {
    ALOGE_IF(!silent,
             "%s: spans overlap horizontally prev=%p, cur=%p",
             name, prev, cur);
    result = false;
  }
 } else if (cur-&gt;top &lt; prev-&gt;bottom) {
  ALOGE_IF(!silent,
           "%s: spans overlap vertically prev=%p, cur=%p",
           name, prev, cur);
  result = false;
 }
</pre>
</div>
</li>
<li>当然，也要检查最后一个元素是不是该区域的边界。
<div class="org-src-container">

<pre class="src src-c++">if (b != reg.getBounds()) {
  result = false;
  ALOGE_IF(!silent,
           "%s: invalid bounds [%d,%d,%d,%d] vs. [%d,%d,%d,%d]", name,
           b.left, b.top, b.right, b.bottom,
           reg.getBounds().left, reg.getBounds().top, 
           reg.getBounds().right, reg.getBounds().bottom);
 }
</pre>
</div>
</li>
<li>最后，要检查一种不可能出现的情况，即mStorage的大小为2。
<div class="org-src-container">

<pre class="src src-c++">if (reg.mStorage.size() == 2) {
  result = false;
  ALOGE_IF(!silent, "%s: mStorage size is 2, which is never valid", name);
 }
</pre>
</div>

<p>
　　到此为上，Region合法性的讨论就结束了。
</p>

<p>
最后总结一下：前面主要引入三个概念: Rect, Span, Region，它们之间
的区别如下 ：
<img src="../images/2016/2016081201.png" alt="2016081201.png" />
</p>
</li>
</ol>


<p>
<b>二、Region的Boolean操作</b>
</p>

<p>
Region的Boolean操作总体主要分主要有如下几种：
</p>
<div class="org-src-container">

<pre class="src src-c++">enum {
    op_nand = region_operator&lt;Rect&gt;::op_nand,
    op_and  = region_operator&lt;Rect&gt;::op_and,
    op_or   = region_operator&lt;Rect&gt;::op_or,
    op_xor  = region_operator&lt;Rect&gt;::op_xor
};
</pre>
</div>

<p>
　　下面我们主要以 <code>op_or</code> 操作为情景，分析Region如何执行这些boolean操
作的。显然，Region可以与Region或Rect之间进行上述的boolean操作。当然，
执行这些操作后，Region可能会变得不合法了，需要进行调整使新的Region
变为合法的，整个过程就会伴随着怎样将Region从不合法的状态调整成合法
的状态，这个过程会涉及到Rect的合并或分解。
</p>

<p>
　　下面我们将分析 <code>boolean_operation(...)</code> 函数的执行过程，因为所有的
这些boolean操作都是基于此函数实现的。我们直接进入关键代码段：
</p>
<div class="org-src-container">

<pre class="src src-c++">size_t lhs_count;
Rect const * const lhs_rects = lhs.getArray(&amp;lhs_count);

region_operator&lt;Rect&gt;::region lhs_region(lhs_rects, lhs_count);
region_operator&lt;Rect&gt;::region rhs_region(&amp;rhs, 1, dx, dy);
region_operator&lt;Rect&gt; operation(op, lhs_region, rhs_region);
{ // scope for rasterizer (dtor has side effects)
  rasterizer r(dst);
  operation(r);
}
</pre>
</div>

<p>
　　我们将上述分为三步：
</p>
<ol class="org-ol">
<li><code>region_operator&lt;Rect&gt; operation(op, lhs_region, rhs_region);</code>
这一步是初始化，为第二步做准备。传递了两个信息：Region进行的什么
操作，以及操作的两个Region对象，这两个Region对象的引用被传递给了
Spanner对象。 <code>region_operator</code> 这个类定义两个Region之间的boolean操
作的步骤，其中定义的内部类region_rasterizer主要作用就是将一个
Rect加入到当前的Region中，其中会涉及到Span与Rect之间的合并。

<div class="org-src-container">

<pre class="src src-c++">class region_rasterizer {
  friend class region_operator;
  virtual void operator()(const RECT&amp; rect) = 0;
public:
  virtual ~region_rasterizer() { };
};
</pre>
</div>
</li>

<li><code>rasterizer r(dst);</code>
　　类rasterrizer是Region类中内部类，它继承自上面提到的
<code>region_rasterizer</code> 类。主要实现了其中的operator()(const RECT&amp;
rect)虚函数。它对Region进行了一些初始化，该Region将是执行boolean
操作后的结果Region。

<div class="org-src-container">

<pre class="src src-c++">rasterizer(Region&amp; reg) 
  : bounds(INT_MAX, 0, INT_MIN, 0), storage(reg.mStorage), head(), tail(), cur() {
  storage.clear();
}
</pre>
</div>
</li>

<li>operation(r);
这步进入了实际的操作过程，将执行如下的函数：

<div class="org-src-container">

<pre class="src src-c++">void operator()(region_rasterizer&amp; rasterizer) {
  RECT current;
  do {
    SpannerInner spannerInner(spanner.lhs, spanner.rhs);
    int inside = spanner.next(current.top, current.bottom);
    spannerInner.prepare(inside);
    do {
      TYPE left, right;
      int inside = spannerInner.next(current.left, current.right);
      if ((op_mask &gt;&gt; inside) &amp; 1) {
        if (current.left &lt; current.right &amp;&amp; 
            current.top &lt; current.bottom) {
          rasterizer(current);
        }
      }
    } while(!spannerInner.isDone());
  } while(!spanner.isDone());
}
</pre>
</div>

<p>
　　在详细分解这个函数的执行过程之前，我们简单描述下Spanner和
SpannerInner这两个类的作用。Spanner相当于Region内部Span集合的迭
代器，它会从Y轴增长的方向逐个迭代Span;而SpannerInner则相当于某个
Span的内部迭代器，它会从X轴增长的方向迭代包含于这个Span内的Rect
对象。
</p>

<p>
　　下面， 描述这个函数的执行步骤：
</p>
<ol class="org-ol">
<li>int inside = spanner.next(current.top, current.bottom);
这步首先会决定当前迭代的Span，以current.top, current.bottom来
指定当前所处的Span。另外，也会根据inside得到两个Region之间的
相对位置信息，其实质是比较两个Region的第一个Span的相对位置关
系：首先，看它们的top值，然后是bottom值。如果这两个Region在Y
轴方向有重叠，就会发生Span的在Y轴的分解，并通过更新
current.top, current.bottom记录下当前所处的新Span。
</li>

<li>spannerInner.prepare(inside);
　　根据上一步得到的两个Region的相对位置信息，来决定X轴方向迭
代的起始值。
</li>

<li>进入循环，直到当前Span内的Rect迭代结束。
<pre class="example">
int inside = spannerInner.next(current.left, current.right);
</pre>

<p>
　　这步每执行一次会更新当前的current.left, current.right的值，
如果两个Region在X轴方向上有重叠，就会在Span内部发生Rect的分解，
并通过更新current.left, current.right记录下当前所处的新的Rect。
根据Region执行的boolean操作的语义，以决定当前所指的Rect是否应
该加入到操作后的结果Region中去，即
</p>

<div class="org-src-container">

<pre class="src src-c++">        　　if ((op_mask &gt;&gt; inside) &amp; 1) {
          　　                    if (current.left &lt; current.right &amp;&amp; 
                                      　　                            current.top &lt; current.bottom) {
            　　                        rasterizer(current);
            　　                    }
          　　                }
</pre>
</div>

<p>
　　下图是两个Region执行合并操作时的过程示意图：
</p>


<div class="figure">
<p><img src="../images/2016/2016081202.png" alt="2016081202.png" />
</p>
</div>

<p>
最后结果中，有三个Span，第一个Span包含Rect 1, 第二个Span包含
Rect 2,3,4， 第三个Span中包含Rect 5。不过上述也只是中间结果，
在执行rasterizer(current);之后，才是最终的结果，所以我们接着
看下rasterizer(current)的执行过程。根据C++虚函数的多态性，
　　这个调用实际会执行到Region::rasterizer类的
operator()(const Rect&amp; rect) 方法，来看下它的具体实现过程：
</p>

<div class="org-src-container">

<pre class="src src-c++">virtual void operator()(const Rect&amp; rect) {
  //ALOGD("&gt;&gt;&gt; %3d, %3d, %3d, %3d",
  //        rect.left, rect.top, rect.right, rect.bottom);
  if (span.size()) {
    if (cur-&gt;top != rect.top) {
      flushSpan();
    } else if (cur-&gt;right == rect.left) {//two rect connected and will merge into one rect.
      cur-&gt;right = rect.right;
      return;
    }
  }
  span.add(rect);
  cur = span.editArray() + (span.size() - 1);
}
</pre>
</div>

<p>
　　简单描述下上述函数所反映的逻辑：如果传入的Rect对象是当前
Span的第一个Rect对象，则直接将其加入到向量span中，对于第二个
及之后加入的Rect，则进行这样的判断，如果当前Rect对象的top值不
等于当前Span的top值，说明是一个新的Span开始，则首先需要通过
fushSpan()将之前Span加入到结果Region中去，可能会涉及到合并的
操作，主要是指相邻两个Span之间的合并;如果当前Rect对象还属于同
一个Span，则看这个Rect是否可以与相邻的Rect进行合并。
</p>
</li>

<li>最后一步，执行Region::rasterizer类的析构函数

<div class="org-src-container">

<pre class="src src-c++">~rasterizer() {
  if (span.size()) {
    flushSpan();
  }
  if (storage.size()) {
    bounds.top = storage.itemAt(0).top;
    bounds.bottom = storage.top().bottom;
    if (storage.size() == 1) {
      storage.clear();
    }
  } else {
    bounds.left  = 0;
    bounds.right = 0;
  }
  storage.add(bounds);
}
</pre>
</div>

<p>
　　首先，执行最后一次flushSpan，确保所有的Span都加入到了结果
Region中，当然，也会执行必要的合并。最后，根据Region合法性的
要求，将Region的边界作为一个Rect对象加入到结果Region中。所以，
最后，我们看到的结果Region是这样的：
</p>


<div class="figure">
<p><img src="../images/2016/2016081203.png" alt="2016081203.png" />
</p>
</div>
</li>
</ol>
<p>
<b>三、T-Junction消除</b>
</p>

<p>
T-Junction问题是图像渲染中的经常碰到的一个问题，特别是3D
Graphics Rendering技术中，T-Junction消除是其中的一个研究课题。那
什么是T-Junction问题呢？
</p>

<p>
下面是对T-Junction问题的描述：
</p>

<p>
　　“A T-Junction is a spot where two polygons meet along the
edge of another polygon”
</p>

<p>
如：
<img src="../images/2016/2016081204.png" alt="2016081204.png" />
</p>

<p>
另一种表述为：
“The location where a vertex of one polygon lies on the edge of
another polygon is called a T-Junction”
</p>


<div class="figure">
<p><img src="../images/2016/2016081205.png" alt="2016081205.png" />
</p>
</div>

<p>
T-Junction会产生什么后果呢，我们先看下Android代码中的描述：
“avoid T-junctions as they cause artifacts in between the
resultant geometry when complex transforms occur.”
</p>

<p>
我的理解是因为图像渲染过程中会基于顶点进行插值，顶点A处的插值点
在图形转换后，并不能保证与顶点A完全重合，所以在生成的图像中
T-Junction处产生亮点，与周围像素不协调。下面我们重点看Android源
码是怎样进行T-Junction消除的。
</p>

<p>
　　在Region类中，专门定义了一个函数：createTJunctionFreeRegion，
它对一个含有T-Junction的Region进行修改，使之变成没有T-Juncion的
Region。最终结果会出现对一些Span的分解。
</p>

<p>
　　根据RegionTest.cpp中的checkVertTJunction函数：
</p>
<div class="org-src-container">

<pre class="src src-c++">void checkVertTJunction(const Rect* lhs, const Rect* rhs) {
  EXPECT_FALSE((rhs-&gt;right &gt; lhs-&gt;left &amp;&amp; rhs-&gt;right &lt; lhs-&gt;right) ||
               (rhs-&gt;left &gt; lhs-&gt;left &amp;&amp; rhs-&gt;left &lt; lhs-&gt;right));
}
</pre>
</div>

<p>
我们可以看到Android视如下几种情况为T-Juction:
<img src="../images/2016/2016081206.png" alt="2016081206.png" />
</p>

<p>
在了解了存在T-Junction的几种存在情况后，我们来看具体是怎样消除
T-Junction的：
</p>
<div class="org-src-container">

<pre class="src src-c++">Region Region::createTJunctionFreeRegion(const Region&amp; r) {
    if (r.isEmpty()) return r;
    if (r.isRect()) return r;

    Vector&lt;Rect&gt; reversed;
    reverseRectsResolvingJunctions(r.begin(), r.end(), reversed, direction_RTL);

    Region outputRegion;
    reverseRectsResolvingJunctions(reversed.begin(), reversed.end(),
            outputRegion.mStorage, direction_LTR);
    outputRegion.mStorage.add(r.getBounds()); // to make region valid, mStorage must end with bounds

#if VALIDATE_REGIONS
    validate(outputRegion, "T-Junction free region");
#endif

    return outputRegion;
}
</pre>
</div>

<p>
可以看到，具体执行T-Junction消除的函数是
reverseRectsResolvingJunctions，而且被调用了两次，这其实也反映了
消除T-Junction过程中的步骤，在这个过程中，需要对Region按以Span为
单位进行两次扫描，第一次从Y轴减小的方向扫描，第二次，从Y轴增长的
方向扫描。每次扫描，都会将T-Junction点消除，进行两次扫描的原因是
因为每次扫描只能消除上述的5种情况。下图是T-Junction点消除后的情
况：
</p>


<div class="figure">
<p><img src="../images/2016/2016081207.png" alt="2016081207.png" />
</p>
</div>

<p>
红色虚线是分解边。可以看到，这个过程会产生许多新的Rect。
</p>
</li>
</ol>

<p>
<b>四、测试与验证</b>
</p>

<p>
　　前面三部分是理论部分，主要是通过阅读源码得到的一些步骤和过程，下
面将通过测试程序来验证我们的理论，看我们的理解是否正正确：
</p>
<ol class="org-ol">
<li>验证Region的boolean操作。
<div class="org-src-container">

<pre class="src src-c++">void test2()
{
  Region r;
  r.clear();
  r.orSelf(Rect(0, 0, 2, 2));
  r.orSelf(Rect(1, 1, 3, 3));
  dump(r, "A|B");
  echo("--------------");

  r.clear();
  r.orSelf(Rect(0, 0, 2, 2));
  r.xorSelf(Rect(1, 1, 3, 3));
  dump(r, "A xor B");
  echo("----------------------------");

  r.clear();
  r.orSelf(Rect(0, 0, 2, 2));
  r.subtractSelf(Rect(1, 1, 3, 3));
  dump(r, "A-B");
  echo("---------------------");
}
</pre>
</div>

<p>
输出结果：
</p>

<pre class="example">
Region: A|B, count = 3

[  0,   0,   2,   1]

 [  0,   1,   3,   2]

 [  1,   2,   3,   3]

 ----------------------

Region: A xor B, count = 4

[  0,   0,   2,   1]

 [  0,   1,   1,   2]

 [  2,   1,   3,   2]

 [  1,   2,   3,   3]

 ----------------------

Region: A-B, count = 2

[  0,   0,   2,   1]

 [  0,   1,   1,   2]

 ----------------------
</pre>

<p>
结果完全符合预期。
</p>


<div class="figure">
<p><img src="../images/2016/2016081321.png" alt="2016081321.png" />
</p>
</div>
</li>

<li>验证T-Junction的消除结果是否与我们的预期一致。

<div class="org-src-container">

<pre class="src src-c++">void test1()
{
  Region r;
  r.clear();
  r.orSelf(Rect(1, 0, 2, 1));
  r.orSelf(Rect(0, 1, 3, 2));
  dump(r, "1");
  echo("----------------------------");
  Region modified = Region::createTJunctionFreeRegion(r);
  dump(modified, "1'");
  echo("------------------------");

  r.clear();
  r.orSelf(Rect(0, 0, 1, 1));
  r.orSelf(Rect(0, 1, 2, 2));
  dump(r, "2");
  echo("-------------------------");
  modified = Region::createTJunctionFreeRegion(r);
  dump(modified, "2'");
  echo("-----------------------------");

  r.clear();
  r.orSelf(Rect(0, 0, 2, 1));
  r.orSelf(Rect(1, 1, 3, 2));
  dump(r, "3");
  echo("-------------------");
  modified = Region::createTJunctionFreeRegion(r);
  dump(modified, "3'");
  echo("--------------------------");

  r.clear();
  r.orSelf(Rect(1, 0, 2, 1);
           r.orSelf(Rect(0, 1, 2, 2));
           dump(r, "4");
           echo("------------------------");
           modified = Region::createTJunctionFreeRegion(r);
           dump(modified, "4'");
           echo("------------------------");

           r.clear();
           r.orSelf(Rect(1, 0, 3, 1));
           r.orSelf(Rect(0, 1, 2, 2));
           dump(r, "5");
           modified = Region::createTJunctionFreeRegion(r);
           dump(modified, "5'");
           echo("--------------------------");

           }
</pre>
</div>

<p>
输出结果：
</p>

<pre class="example">
Region: 1, count = 2

[  1,   0,   2,   1]

 [  0,   1,   3,   2]

 ----------------------

Region: 1', count = 4

[  1,   0,   2,   1]

 [  0,   1,   1,   2]

 [  1,   1,   2,   2]

 [  2,   1,   3,   2]

 ----------------------

Region: 2, count = 2

[  0,   0,   1,   1]

 [  0,   1,   2,   2]

 ----------------------

Region: 2', count = 3

[  0,   0,   1,   1]

 [  0,   1,   1,   2]

 [  1,   1,   2,   2]

 ----------------------

Region: 3, count = 2

[  0,   0,   2,   1]

 [  1,   1,   3,   2]

 ----------------------

Region: 3', count = 4

[  0,   0,   1,   1]

 [  1,   0,   2,   1]

 [  1,   1,   2,   2]

 [  2,   1,   3,   2]

 ----------------------

Region: 4, count = 2

[  1,   0,   2,   1]

 [  0,   1,   2,   2]

 ----------------------

Region: 4', count = 3

[  1,   0,   2,   1]

 [  0,   1,   1,   2]

 [  1,   1,   2,   2]

 ----------------------

Region: 5, count = 2

[  1,   0,   3,   1]

 [  0,   1,   2,   2]

 ----------------------

Region: 5', count = 4

[  1,   0,   2,   1]

 [  2,   0,   3,   1]

 [  0,   1,   1,   2]

 [  1,   1,   2,   2]

 ----------------------
</pre>

<p>
这个结果也符合预期。
</p>
</li>

<li>练习题

<p>
构造如下Region：
</p>
<div class="org-src-container">

<pre class="src src-c++">    Region r;
 // |xxxx   |
 // | xxxx  |
 // |  xxxx |
 // |   xxxx|
for (int i = 0; i &lt; 4; i++) {
    r.orSelf(Rect(i,i,i+4,i+1));
}
</pre>
</div>

<p>
消除T-Junction前有4个Rect, 消除T-Junction后有16个Rect。
</p>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Binder通信过程中的用户空间线程池的管理</h2>
<div class="outline-text-2" id="text-5">
<p>
在Binder通信机制里，客户端与服务端之间的通信是在专门的IPC通信线程
中进行的。这些线程构成一个线程池。线程的创建和销毁是在用户空间进行
的，而对线程的控制是在驱动层进行的，即驱动控制线程池中线程的生命，
而线程本身则是运行在用户空间的。驱动层是通过 <code>BR_SPAWN_LOOPER</code> 向用户
空间发送创建新线程的命令。
</p>

<p>
线程池的大小可以设置。默认情况下，线程池只有一个主线程，它在进程生
命周期期间是不会退出。与线程池相关的几个变量设置在struct
<code>binder_proc</code> 结构体中：
</p>
<div class="org-src-container">

<pre class="src src-c">struct binder_proc {
        ...
        int max_threads;//max thread
        int requested_threads;//
        int requested_threads_started;//requested thread seq No
        int ready_threads;//available for use
        ...
};
</pre>
</div>

<p>
其中，=max_threads= 表示当前进程线程池的大小。ioctl命令
<code>BINDER_SET_MAX_THREADS</code> 用来设置这个值，默认情况下是0，即不开启线程
池。 <code>ready_threads</code> 表示当前线程池中有没有可用的空闲线程。
<code>requested_threads</code> 请求开启线程的数量。 <code>requested_threads_started</code> 表示
当前已经接受请求开启的线程数量。
</p>

<p>
对于IPC通信的服务端进程，一般会执行如下的调用启动线程池：
</p>

<div class="org-src-container">

<pre class="src src-c++">ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);
ProcessState::self()-&gt;startThreadPool();
IPCThread::self()-&gt;joinThreadPool();
</pre>
</div>

<p>
上述代码会在一个进程中执行，并产生两个线程，其中一个是进程的主线程，
但这两个线程都是Binder主线程，即他不会纳入线程池的管理。网上有不少
说法是最后一个调用看起来是多余的，原因是去掉后，也可以正常执行，但
是其实不然。在我看来，在主线程中调用
<code>IPCThread::self()-&gt;joinThreadPool()</code> 的一层目的是确保前一句调用产生
的线程不会因为执行到了main函数结尾而被迫退出，因为
<code>ProcessState::self()-&gt;startThreadPool()</code> 不会导致主线程阻塞，而
<code>IPCThread::self()-&gt;joinThreadPool()</code> 调用才会导致主线程阻塞。并且，
它们提供相同的功能：它能处理Binder驱动发送上来的一些请求或返回值，
进一步提高了Binder命令处理的吞吐量。当然，如果在他们之间加入了让主
线程阻塞的代码，则最后的函数调用是可以省略的，否则是不能省略的。
</p>

<p>
执行完上述语句后, 已经有两个服务线程了，此时线程池线程的数量为0，
后续可以创建4个线程。默认情况下，线程池中没有线程，由于本身已经有
了2个线程可用，一般情况下，能满足要求。但是，当有多个并发的IPC请求
时，可能会触发内核增加更多的IPC通信线程来服务这些请求。当接受
Binder驱动从内核中发出的 <code>BR_SPAWN_LOOPER</code> 命令时，会启动一个非Binder主
线程。我们来看下在什么情况下会触发这种情况：
</p>
<div class="org-src-container">

<pre class="src src-c++">if (proc-&gt;requested_threads + proc-&gt;ready_threads == 0 &amp;&amp;
            proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;
            (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |
             BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */
             /*spawn a new thread if we leave this out */) {
                proc-&gt;requested_threads++;
                binder_debug(BINDER_DEBUG_THREADS,
                             "%d:%d BR_SPAWN_LOOPER\n",
                             proc-&gt;pid, thread-&gt;pid);
                if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))
                        return -EFAULT;
                binder_stat_br(proc, thread, BR_SPAWN_LOOPER);
        }
</pre>
</div>

<p>
在请求的线程数和空闲的线程数为零且已经请求并开启的线程数小于线程池
的最大允许线程数量时，就向用户空间发送命令，以开启新的接收线程来处
理请求。因为此时，接收进程中所有的线程都在忙碌中。
</p>

<p>
在用户空间通过如下调用启动线程：
</p>
<pre class="example">
mProcess-&gt;spawnPooledThread(false);
</pre>

<p>
最终会调用如下函数：
</p>
<div class="org-src-container">

<pre class="src src-c++">void IPCThreadState::joinThreadPool(bool isMain)
{
    LOG_THREADPOOL("**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n", (void*)pthread_self(), getpid());

    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);
    …
}
</pre>
</div>

<p>
这种情况下，会通过向Binder驱动发 <code>BC_REGISTER_LOOPER</code> 通知驱动用户空间线
程已经创建，这样驱动也会做些数据统计：
</p>
<div class="org-src-container">

<pre class="src src-c"> case BC_REGISTER_LOOPER:
…
} else {
    proc-&gt;requested_threads--;
    proc-&gt;requested_threads_started++;
  }
thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;
break;
</pre>
</div>

<p>
驱动会更新 <code>proc-&gt;requested_threads_started</code> 来统计当前已经请求开启并成
功开启的线程数量，这个值将作为判断线程池是否已经满的依据。
</p>

<p>
而在Binder驱动层，会跟用户空间的线程关联一个 <code>struct binder_thread</code>
实例，这个结构记录了内核空间的在该线程上执行的一些IPC状态信息。其数
据结构定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">struct binder_thread {
        struct binder_proc *proc;  //线程所属的进程
        struct rb_node rb_node;  //红黑树的结点，进程通过该结点将线程加入到红黑树中
        int pid; //线程的pid
        int looper;  //线程所处的状态
        struct binder_transaction *transaction_stack;//transaction session list on this thread
        struct list_head todo; //在该线程上的Task列表
        uint32_t return_error; /* Write failed, return error code in read buf */
        uint32_t return_error2; /* Write failed, return error code in read */
                /* buffer. Used when sending a reply to a dead process that */
                /* we are also waiting on */
        wait_queue_head_t wait; //该线程的等待队列
        struct binder_stats stats; //统计该线程上的命令数量
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Binder通信相关的类简要分析</h2>
<div class="outline-text-2" id="text-6">
<p>
<b>一、BpBinder</b>
</p>

<p>
这个类通常作为IPC通信的Client端，或者说Remote端，提供实际的IPC基础
通信服务。在代码中通常不直接使用到该类，一般以成员变量的形式，包含
于BpRefBase类中，通过remote()方法引用该成员变量。继承关系如下：
</p>

<p>
BpXXX &#x2013;&gt; BpInterface&lt;IXXX&gt; &#x2013;&gt; BpRefBase
</p>

<p>
在BpXXX方法中，就可以直接通过remote()方法引用到BpBinder实例，继而
利用其提供的IPC通信功能，通过Binder协议与另一端进行通信。
</p>

<p>
BpBinder类的定义说明
</p>

<p>
成员变量分析：
</p>

<div class="org-src-container">

<pre class="src src-c++">const   int32_t             mHandle;//handle for remote obj

            void                reportOneDeath(const Obituary&amp; obit);
            bool                isDescriptorCached() const;

    mutable Mutex               mLock;
            volatile int32_t    mAlive;
            volatile int32_t    mObitsSent; //we have already send Obit? can notify is object is already dead
            Vector&lt;Obituary&gt;*   mObituaries;//dead notification listerners
            ObjectManager       mObjects;
            Parcel*             mConstantData;
    mutable String16            mDescriptorCache;
</pre>
</div>

<p>
mHandle: 这是一个重要的成员变量，代表Binder驱动为一个远程对象分配
的一个句柄，在Binder驱动中，通过该句柄号，找到对应的Binder引用结点，
通过Binder引用结点，找到其引用的位于不同进程中的一个Binder结点，从
而将利用该Binder结点将通信数据路由到通信的另一端所在的进程。
</p>

<p>
mLock：保护BpBinder对象的一些方法的访问，从而保证任何时刻不会同时
执行两个或以上方法。
</p>

<p>
mAlive：Binder IPC通信是否处于活跃状态。
</p>

<p>
mObjects： 对象管理，主要是对Java Binder对象的管理。
</p>

<p>
mConstantData： 未使用
</p>

<p>
mDescriptorCache：保存接口描述信息。
</p>

<p>
主要方法分析：
</p>

<div class="org-src-container">

<pre class="src src-c++">virtual status_t    transact(   uint32_t code,
                                const Parcel&amp; data,
                                Parcel* reply,
                                uint32_t flags = 0);
</pre>
</div>

<p>
该方法是Binder IPC通信的入口，其实质上是调用IPCThreadState类的
transact方法。
</p>

<p>
如下两个接口则是提供监听远程对象死亡通知的接口。
</p>

<div class="org-src-container">

<pre class="src src-c++">virtual status_t    linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient,
                                void* cookie = NULL,
                                uint32_t flags = 0);
virtual status_t    unlinkToDeath(  const wp&lt;DeathRecipient&gt;&amp; recipient,
                                    void* cookie = NULL,
                                    uint32_t flags = 0,
                                    wp&lt;DeathRecipient&gt;* outRecipient = NULL);
</pre>
</div>


<p>
BpBinder对象作为远程对象的代理，它会跟踪远程对象的状态（实质上是在
驱动中，跟踪Binder通信结点，结点死亡的信息也是通过驱动层向用户空间
发送的），一旦接收到死亡通知，则会调用如下接口通知所有监听者：
</p>

<pre class="example">
void  sendObituary();
</pre>

<p>
其会调用如下方法调用所有监听者提供的回调函数：
</p>
<pre class="example">
void  reportOneDeath(const Obituary&amp; obit);
</pre>

<p>
<b>二、BBinder</b>
</p>

<p>
BBinder类作为Binder IPC通信的Server端或Local端，处理来自Client端或
Remote端的服务请求。它的主要方法就是处理请求：
</p>

<div class="org-src-container">

<pre class="src src-c++">status_t BBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
</pre>
</div>

<p>
在IPCThreadState中，是通过如下方式调用到上述的接口的：
</p>

<div class="org-src-container">

<pre class="src src-c++">IPCThreadState(979)：         
case BR_TRANSACTION:
           …   
if (tr.target.ptr) {//local 
                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
                const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
                if (error &lt; NO_ERROR) reply.setError(error);

            } else {//remote
                const status_t error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
                if (error &lt; NO_ERROR) reply.setError(error);
            }
</pre>
</div>

<p>
<b>三、Java层类</b>
</p>

<p>
Java层的类主要有Binder和BinderProxy，其中Binder跟BBinder一样，属于
Server或Local端，而BinderProxy则与BpBinder一样，属于Client端或
Remote端。
</p>

<p>
对于BinderProxy类对象，跟BpBinder一样，同样是作为XXXProxy的成员变
量的形式包含于其中。
</p>

<p>
XXXProxy &#x2013;&gt; IXXX &#x2013;&gt; IInterface.
</p>

<p>
在JNI层，定义了两个转换函数：
</p>
<div class="org-src-container">

<pre class="src src-c++">jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val);
sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj);
</pre>
</div>

<p>
上述两种函数提供了Java对象（主要是Binder和BinderProxy对象）与
Native层IBinder对象之间的相互转换接口。
</p>

<p>
当我们调用transact方法时，会经历如下一些过程：
</p>

<div class="org-src-container">

<pre class="src src-java">//in BinderProxy.java
public native boolean transact(int code, Parcel data, Parcel reply,
            int flags) throws RemoteException;
</pre>
</div>

<p>
&#x2013;&gt;
</p>

<div class="org-src-container">

<pre class="src src-c++">//in android_util_Binder.cpp
static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,
        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException
{
     …
    IBinder* target = (IBinder*)
        env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    …
    //printf("Transact from Java code to %p sending: ", target); data-&gt;print();
    status_t err = target-&gt;transact(code, *data, reply, flags);
    …
    return JNI_FALSE;
}
</pre>
</div>

<p>
其中gBinderProxyOffsets.mObject是通过javaObjectForIBinder设置的，
它的原型如下：
</p>
<pre class="example">
jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val);
</pre>

<p>
对于上述函数，除非参数val是JavaBBinder（继承自BBinder）对象，否则，
就创建一个BinderProxy对象，它与一个BpBinder对象关联。
</p>

<p>
&#x2013;&gt; 
</p>

<p>
接下来就会调用某个IBinder(C++类)对象的transact方法。这个IBinder对
象是BpBinder类型的，即：
</p>
<pre class="example">
BpBinder::transact(…) 
</pre>

<p>
&#x2013;&gt;
</p>
<pre class="example">
IPCThreadState::transact(…)
</pre>

<p>
它会向Binder驱动发送一个 <code>BC_TRANSACTION</code> 命令，Binder驱动进行处理，将
请求路由给通信的另一端，并通过命令 <code>BR_TRANSACTION</code> 告知用户空间，有新
的通信请求。在介绍BBinder的时候，我们提到过，接收端会调用
BBinder::transact(…)来处理请求，对于Java层的通信来说，则会实际调
用JavaBBinder::transact(…)来处理请求，而实际上会调用
onTransact(…)（重载了BBinder的方法），如下所示：
</p>

<div class="org-src-container">

<pre class="src src-c++">class JavaBBinder : public BBinder
{
  …
  protected:
  …

  virtual status_t onTransact(
                              uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0)
  {
    …

      //printf("Transact from %p to Java code sending: ", this);
      //data.print();
      //printf("\n");
      jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,
                                            code, (int32_t)&amp;data, (int32_t)reply, flags);

    …

      // Need to always call through the native implementation of
      // SYSPROPS_TRANSACTION.
      if (code == SYSPROPS_TRANSACTION) {
        BBinder::onTransact(code, data, reply, flags);
      }

    …
      }

  …
};
</pre>
</div>

<p>
&#x2013;&gt;
</p>

<div class="org-src-container">

<pre class="src src-java">//in Binder.java
// Entry point from android_util_Binder.cpp's onTransact
    private boolean execTransact(int code, int dataObj, int replyObj,
            int flags) {
        …
        boolean res;
        try {
            res = onTransact(code, data, reply, flags);
        } …

        return res;
    }
</pre>
</div>

<p>
最终调用到了Binder类的onTransact方法。从Binder类派生的类都会重载该方法。
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Binder结点管理</h2>
<div class="outline-text-2" id="text-7">
<p>
在Binder驱动中，Binder结点随着进程IPC通信开始而生，随着进程IPC通信
结束而亡，换句话说，Binder结点是维系IPC通信的基础，而且一个Binder
结点也只能在完全无IPC通信的情况下被删除。本文将重点研究Binder结点
从生到死的过程。
</p>

<p>
Binder结点作为IPC通信过程中的实体，是IPC通信的媒介。在描述一个
Binder进程信息的数据结构中，与结点相关的成员变量有：
</p>

<div class="org-src-container">

<pre class="src src-c">struct binder_proc {
        struct hlist_node proc_node;// list node for global binder_procs hlist
        ...
        struct rb_root nodes;
        struct rb_root refs_by_desc;
        struct rb_root refs_by_node;
        ...
};
</pre>
</div>

<p>
其中，nodes记录了当前进程创建的Binder结点。而 <code>refs_by_desc</code> 和
<code>refs_by_node</code> 都记录的是Binder结点引用，换句话说，它代表一个对其他进程
中创建的Binder结点的引用。Nodes链表的大小反映了有多少进程在向当前
进程请求服务，而结点引用则反映了当前进程在向哪些进程请求服务。
</p>

<p>
创建Binder结点的函数是 <code>binder_new_node</code> 。在分析此函数之前，我们先分析
一下Binder驱动中结点的数据结构定义：
</p>

<div class="org-src-container">

<pre class="src src-c">struct binder_node {
        int debug_id; 
        struct binder_work work;
        union {
                struct rb_node rb_node;
                struct hlist_node dead_node;
        };
        struct binder_proc *proc;
        struct hlist_head refs;
        int internal_strong_refs;
        int local_weak_refs;
        int local_strong_refs;
        void __user *ptr;
        void __user *cookie;
        unsigned has_strong_ref:1;
        unsigned pending_strong_ref:1;
        unsigned has_weak_ref:1;
        unsigned pending_weak_ref:1;
        unsigned has_async_transaction:1;
        unsigned accept_fds:1;
        unsigned min_priority:8;
        struct list_head async_todo;
};
</pre>
</div>

<p>
下面分别解释上述各个成员变量的意义：
</p>
<ol class="org-ol">
<li><code>debug_id</code> ： 结点的一个数字序号标记，根据全局变量
<code>binder_last_id</code> 来维护并分配， <code>binder_last_id</code> 是Binder驱动
全局变量，且单调递增的。
</li>
<li>work：类型为 <code>BINDER_WORK_NODE</code> 的 <code>binder_work</code> 结点，添加
到线程上的todo链表中去处理，主要处理结点的引用计数。
</li>
<li>联合体： <code>rb_node</code> 代表此结点在进程全局红黑树 <code>binder_procs</code> 上
的一个结点。而 <code>dead_node</code> 代表红黑树 <code>binder_dead_nodes</code> 中的
一个结点。根据当前结点的状态，将决定将结点加入到哪个全局链表中。
</li>
<li>proc: 与结点相关联的 <code>binder_proc</code> 。
</li>
<li>refs:  <code>binder_ref</code> 链表，记录当前其他进程对该Binder结点的引用。
</li>
<li><code>internal_strong_refs</code> ：内部强引用计数
</li>
<li><code>local_weak_refs</code> ：本地弱引用计数。
</li>
<li><code>local_strong_refs</code> ：本地强引用计数。
</li>
<li><code>ptr</code> ：通常指本地Binder对象的内存地址，当其是0号结点时，该指针为空。
</li>
<li>cookies: 通常指本地Binder对象的私有数据。
</li>
<li><code>has_strong_ref</code> ：是否拥有强引用。
</li>
<li><code>pending_strong_ref</code> ：对结点的强引用是否处理完成
（ <code>BC_ACQUIRE_DONE</code> ）
</li>
<li><code>has_weak_ref</code> ：是否拥有弱引用。
</li>
<li><code>pending_weak_ref</code> ：对结点的弱引用是否处理完成
（ <code>BC_INCREFS_DONE</code> ）
</li>
<li><code>has_async_transaction</code> ：拥有异步事务？
</li>
<li><code>accept_fds</code> ：是否允许传递文件描述符？
</li>
<li><code>min_priority</code> ：最低优先级
</li>
<li><code>async_todo</code> ：该结点上的异步工作队列。
</li>
</ol>

<p>
<b>新结点的创建</b>
</p>

<p>
在函数 <code>binder_new_node()</code> ，创建的新结点将会加入到当前进程的结点树中，
这些结点通过红黑树的结构来维护，以本地Binder对象的内存地址的大小作
为排序依据。此函数主要是在 <code>BR_TRANSACTION</code> 中，为发送方创建相应的本地
结点，以便接收方能够通过该结点获取关于发送方的一些信息。当然，在调
用 <code>BINDER_SET_CONTEXT_MGR</code> 命令时，也会调用该函数创建一个特殊的结
点。
</p>

<p>
<b>结点引用计数管理</b>
</p>

<p>
结点引用计数的管理主要通过如下两个函数：
</p>
<div class="org-src-container">

<pre class="src src-c">static int binder_inc_node(struct binder_node *node, int strong, int internal,
                           struct list_head *target_list)
static int binder_dec_node(struct binder_node *node, int strong, int internal)
</pre>
</div>

<p>
<b>结点引用</b>
</p>

<p>
结点引用与结点密不可分。事实上，可以认为结点引用是结点在另一个进程
中的代理。它们之间的关系是多对一的关系，即一个结点可以对应多个结点
引用，但是结点本身只能存在于一个进程中，且结点引用与结点一般是属于
不同进程的。它的数据结构定义如下：
</p>

<div class="org-src-container">

<pre class="src src-c">struct binder_ref {
        /* Lookups needed: */
        /*   node + proc =&gt; ref (transaction) */
        /*   desc + proc =&gt; ref (transaction, inc/dec ref) */
        /*   node =&gt; refs + procs (proc exit) */
        int debug_id;
        struct rb_node rb_node_desc;
        struct rb_node rb_node_node;
        struct hlist_node node_entry;
        struct binder_proc *proc;
        struct binder_node *node;
        uint32_t desc;
        int strong;
        int weak;
        struct binder_ref_death *death;
};
</pre>
</div>

<p>
下面分别解释上述各个成员变量的意义：
</p>
<ol class="org-ol">
<li><code>debug_id</code> ：同结点的 <code>debug_id</code> 意义一样，一个数据序号标记。
</li>
<li><code>rb_node_desc</code> ：代表 <code>binder_proc</code> 中红黑树 <code>refs_by_desc</code> 中的一个结点，以desc为索引，即结点引用的句柄号作为排序依据。
</li>
<li><code>rb_node_node</code> ：代表 <code>binder_proc</code> 中红黑树 <code>refs_by_node</code> 中的一个结点，以node为索引，即结点的内存地址作为排序依据。
</li>
<li><code>node_entry</code> ：作为node所拥有的结点引用链表中的一个结点
</li>
<li>proc：该结点引用相关联的 <code>binder_proc</code>
</li>
<li>node: 该结点引用所关联的结点
</li>
<li>desc：该结点引用的句柄号
</li>
<li>strong: 该结点引用的强引用计数
</li>
<li>weak: 该结点引用的弱引用计数
</li>
<li>death：该结点引用的死亡通知链表，主要通知它所引用的结点的死亡
消息。
</li>
</ol>

<p>
系统中所有的Binder实体以及每个实体在各个进程中的引用都登记在驱动中；
驱动需要记录Binder引用 -&gt;实体之间多对一的关系；为引用找到对应的实
体；在某个进程中为实体创建或查找到对应的引用；记录Binder的归属地
（位于哪个进程中）；
</p>

<p>
函数
</p>
<pre class="example">
static struct binder_ref binder_get_ref(struct binder_proc *proc, uint32_t desc)
</pre>
<p>
用于查询某个句柄号为desc的 <code>struct binder_ref</code> 对象，而函数 
</p>
<pre class="example">
static struct binder_ref *binder_get_ref_for_node(struct binder_proc *proc,  struct binder_node *node)
</pre>

<p>
则是为某个结点对象创建一个结点引用对象。
</p>

<p>
<b>结点引用计数管理</b>
</p>

<p>
结点引用计数管理主要通过如下两个函数：
</p>
<div class="org-src-container">

<pre class="src src-c">static int binder_inc_ref(struct binder_ref *ref, int strong,
                          struct list_head *target_list)
static int binder_dec_ref(struct binder_ref *ref, int strong)
</pre>
</div>

<p>
从 <code>binder_inc_ref</code> 里面调用 <code>binder_inc_node，internal</code> 为1，直接
调用 <code>binder_inc_node</code> 时，internal为0。
</p>

<p>
所以， <code>node-&gt;internal_strong_refs</code> 统计的是 <code>binder_ref</code> 对远程结点的强引用。
对结点本身来说， <code>node-&gt;internal_strong_refs</code> 的值也反映了当前有多少个远
程结点（ <code>binder_ref</code> ）强引用指向自己。
</p>

<p>
<code>node-&gt;local_strong_refs</code> 则统计的是对本地结点的强引用，这个值反映了当
前进程中有多少个强引用指向自己。
</p>

<p>
<b>Binder驱动对结点引用计数的管理</b>
</p>

<p>
用户空间可以通过如下一个命令来增加或减少结点的引用计数：
</p>

<ol class="org-ol">
<li><code>BC_INCREFS</code>  
</li>
<li><code>BC_ACQUIRE</code>  
</li>
<li><code>BC_RELEASE</code>
</li>
<li><code>BC_DECREFS</code>
</li>
</ol>

<p>
IPCThreadState类中定义了如下几个相关接口：
</p>
<div class="org-src-container">

<pre class="src src-c">incStrongHandle(int32_t handle)
incWeakHandle(int32_t handle)
decStrongHandle(int32_t handle)
decWeakHandle(int32_t handle)
</pre>
</div>

<p>
分别会向驱动发送上述几个命令。
这个命令带的参数是结点的句柄号。 这种方法是直接改变结点的引用计数。
在驱动中也可能直接改变结点的引用计数，
</p>
<pre class="example">
binder_inc_node(target_node, 1, 0, NULL)，
</pre>
<p>
有一个共同点是target_list参数都为NULL。
</p>

<p>
第二种情况是，在处理TRANSACTION期间，Binder驱动改变了传输中的结点
引用计数，然后通过如下几个命令返回给用户空间做处理：
</p>
<ol class="org-ol">
<li><code>BR_ACQUIRE</code>
</li>
<li><code>BR_INCREFS</code>
</li>
<li><code>BR_RELEASE</code>
</li>
<li><code>BR_DECREFS</code>
</li>
</ol>

<p>
其中，当将创建本进程中的某个结点的结点引用对象时，需要传入一个
<code>target_list</code> 参数，提交一个 <code>BINDER_WORK_NODE</code> 类型的
<code>binder_work</code> ，以处理驱动
中的结点引用计数管理，同时，以通过上述几个命令通知用户空间维护相对
应的对象强弱引用计数。
</p>

<div class="org-src-container">

<pre class="src src-c">binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,
                                       &amp;thread-&gt;todo);
</pre>
</div>

<p>
标识Node有强引用或弱引用，并增加引用计数。
</p>

<div class="org-src-container">

<pre class="src src-c">struct binder_work {
        struct list_head entry;
        enum {
                BINDER_WORK_TRANSACTION = 1,  //代表一次进程间业务通信
                BINDER_WORK_TRANSACTION_COMPLETE,
                BINDER_WORK_NODE, //结点引用计数管理
                BINDER_WORK_DEAD_BINDER,
                BINDER_WORK_DEAD_BINDER_AND_CLEAR,
                BINDER_WORK_CLEAR_DEATH_NOTIFICATION,
        } type;
};
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Fu Yajun</p>
<p class="date">Created: 2018-09-12 Wed 17:38</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.0.50.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
